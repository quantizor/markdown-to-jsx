---
title: GitHub Flavored Markdown विनिर्देश
version: 0.29
date: '2019-04-06'
license: '[CC-BY-SA 4.0](http://creativecommons.org/licenses/by-sa/4.0/)'
---

# परिचय

## GitHub Flavored Markdown क्या है?

GitHub Flavored Markdown, जिसे अक्सर GFM के रूप में संक्षिप्त किया जाता है, Markdown की वह बोली है जो वर्तमान में GitHub.com और GitHub Enterprise पर उपयोगकर्ता सामग्री के लिए समर्थित है।

यह औपचारिक विनिर्देश, CommonMark Spec पर आधारित, इस बोली के सिंटैक्स और सिमेंटिक्स को परिभाषित करता है।

GFM, CommonMark का एक सख्त सुपरसेट है। GitHub उपयोगकर्ता सामग्री में समर्थित सभी सुविधाएं जो मूल CommonMark Spec में निर्दिष्ट नहीं हैं, उन्हें **एक्सटेंशन** के रूप में जाना जाता है, और इस तरह हाइलाइट किया जाता है।

जबकि GFM विभिन्न प्रकार के इनपुट का समर्थन करता है, यह ध्यान देने योग्य है कि GitHub.com और GitHub Enterprise वेबसाइट की सुरक्षा और स्थिरता सुनिश्चित करने के लिए GFM को HTML में परिवर्तित करने के बाद अतिरिक्त पोस्ट-प्रोसेसिंग और सैनिटाइज़ेशन करते हैं।

## Markdown क्या है?

Markdown संरचित दस्तावेज़ लिखने के लिए एक सादा टेक्स्ट फ़ॉर्मेट है, जो ईमेल और usenet पोस्ट में फ़ॉर्मेटिंग इंगित करने के सम्मेलनों पर आधारित है। इसे John Gruber (Aaron Swartz की मदद से) द्वारा विकसित किया गया था और 2004 में एक [सिंटैक्स विवरण](http://daringfireball.net/projects/markdown/syntax) और Markdown को HTML में बदलने के लिए एक Perl स्क्रिप्ट (`Markdown.pl`) के रूप में जारी किया गया था। अगले दशक में, कई भाषाओं में दर्जनों कार्यान्वयन विकसित किए गए। कुछ ने मूल Markdown सिंटैक्स को फ़ुटनोट्स, टेबल्स और अन्य दस्तावेज़ तत्वों के सम्मेलनों के साथ विस्तारित किया। कुछ ने Markdown दस्तावेज़ों को HTML के अलावा अन्य फ़ॉर्मेट में रेंडर करने की अनुमति दी। Reddit, StackOverflow, और GitHub जैसी वेबसाइटों पर लाखों लोग Markdown का उपयोग कर रहे थे। और Markdown का उपयोग वेब से परे, किताबें, लेख, स्लाइड शो, पत्र और व्याख्यान नोट्स लिखने के लिए किया जाने लगा।

जो चीज़ Markdown को कई अन्य हल्के मार्कअप सिंटैक्स से अलग करती है, जो अक्सर लिखने में आसान होते हैं, वह इसकी पठनीयता है। जैसा कि Gruber लिखते हैं:

> Markdown के फ़ॉर्मेटिंग सिंटैक्स का प्रमुख डिज़ाइन लक्ष्य इसे यथासंभव पठनीय बनाना है। विचार यह है कि Markdown-फ़ॉर्मेट किया गया दस्तावेज़ सादे टेक्स्ट के रूप में, बिना यह देखे कि इसे टैग या फ़ॉर्मेटिंग निर्देशों के साथ चिह्नित किया गया है, प्रकाशित करने योग्य होना चाहिए।
> (<http://daringfireball.net/projects/markdown/>)

इस बात को [AsciiDoc](http://www.methods.co.nz/asciidoc/) के एक नमूने की Markdown के समतुल्य नमूने के साथ तुलना करके स्पष्ट किया जा सकता है। यहां AsciiDoc मैनुअल से AsciiDoc का एक नमूना है:

```
1. List item one.
+
List item one continued with a second paragraph followed by an
Indented block.
+
.................
$ ls *.sh
$ mv *.sh ~/tmp
.................
+
List item continued with a third paragraph.

2. List item two continued with an open block.
+
--
This paragraph is part of the preceding list item.

a. This list is nested and does not require explicit item
continuation.
+
This paragraph is part of the preceding list item.

b. List item b.

This paragraph belongs to item two of the outer list.
--
```

और यहां Markdown में समतुल्य है:

```
1.  List item one.

    List item one continued with a second paragraph followed by an
    Indented block.

        $ ls *.sh
        $ mv *.sh ~/tmp

    List item continued with a third paragraph.

2.  List item two continued with an open block.

    This paragraph is part of the preceding list item.

    1. This list is nested and does not require explicit item continuation.

       This paragraph is part of the preceding list item.

    2. List item b.

    This paragraph belongs to item two of the outer list.
```

AsciiDoc संस्करण, यकीनन, लिखने में आसान है। आपको इंडेंटेशन के बारे में चिंता करने की आवश्यकता नहीं है। लेकिन Markdown संस्करण पढ़ने में बहुत आसान है। सूची आइटमों का नेस्टिंग स्रोत में नज़र आता है, न कि केवल प्रोसेस किए गए दस्तावेज़ में।

## विनिर्देश की आवश्यकता क्यों है?

John Gruber का [Markdown के सिंटैक्स का विहित विवरण](http://daringfireball.net/projects/markdown/syntax) सिंटैक्स को स्पष्ट रूप से निर्दिष्ट नहीं करता है। यहां कुछ प्रश्नों के उदाहरण हैं जिनका यह उत्तर नहीं देता है:

1.  सबलिस्ट के लिए कितना इंडेंटेशन आवश्यक है? विनिर्देश कहता है कि
    कंटिन्यूएशन पैराग्राफ़ को चार स्पेस इंडेंट करने की आवश्यकता है, लेकिन
    सबलिस्ट के बारे में पूरी तरह से स्पष्ट नहीं है। यह सोचना स्वाभाविक है कि
    उन्हें भी चार स्पेस इंडेंट किया जाना चाहिए, लेकिन `Markdown.pl`
    इसकी आवश्यकता नहीं है। यह शायद ही एक "corner case" है, और इस मुद्दे पर
    कार्यान्वयनों के बीच विचलन अक्सर वास्तविक दस्तावेज़ों में उपयोगकर्ताओं के लिए आश्चर्य का कारण बनता है। ([John
    Gruber की यह टिप्पणी](https://web.archive.org/web/20170611172104/http://article.gmane.org/gmane.text.markdown.general/1997) देखें।)

2.  क्या ब्लॉक कोट या हेडिंग से पहले खाली लाइन की आवश्यकता है?
    अधिकांश कार्यान्वयनों को खाली लाइन की आवश्यकता नहीं है। हालांकि,
    यह हार्ड-रैप्ड टेक्स्ट में अप्रत्याशित परिणामों का कारण बन सकता है, और
    पार्सिंग में अस्पष्टताओं का भी (ध्यान दें कि कुछ कार्यान्वयन
    हेडिंग को blockquote के अंदर रखते हैं, जबकि अन्य नहीं करते)।
    (John Gruber ने भी [खाली लाइनों की आवश्यकता के पक्ष में बात की है](https://web.archive.org/web/20170611172104/http://article.gmane.org/gmane.text.markdown.general/2146)।)

3.  क्या इंडेंटेड कोड ब्लॉक से पहले खाली लाइन की आवश्यकता है?
    (`Markdown.pl` इसकी आवश्यकता है, लेकिन यह दस्तावेज़ीकरण में उल्लिखित नहीं है,
    और कुछ कार्यान्वयनों को इसकी आवश्यकता नहीं है।)

    ```markdown
    paragraph
    code?
    ```

4.  सूची आइटम को `<p>` टैग में कब रैप किया जाता है, इसे निर्धारित करने का सटीक नियम क्या है? क्या एक सूची आंशिक रूप से "loose" और आंशिक रूप से
    "tight" हो सकती है? हमें इस तरह की सूची के साथ क्या करना चाहिए?

    ```markdown
    1. one

    2. two
    3. three
    ```

    या यह?

    ```markdown
    1.  one
        - a

        - b

    2.  two
    ```

    (There are some relevant comments by John Gruber
    [here](https://web.archive.org/web/20170611172104/http://article.gmane.org/gmane.text.markdown.general/2554).)

5.  क्या सूची मार्करों को इंडेंट किया जा सकता है? क्या क्रमबद्ध सूची मार्करों को दाएं-संरेखित किया जा सकता है?

    ```markdown
    8.  item 1
    9.  item 2
    10. item 2a
    ```

6.  क्या यह अपने दूसरे आइटम में थीमैटिक ब्रेक के साथ एक सूची है,
    या थीमैटिक ब्रेक द्वारा अलग की गई दो सूचियां हैं?

    ```markdown
    - a

    ---

    - b
    ```

7.  जब सूची मार्कर संख्याओं से बुलेट्स में बदलते हैं, तो क्या हमारे पास
    दो सूचियां हैं या एक? (Markdown सिंटैक्स विवरण दो का सुझाव देता है,
    लेकिन perl स्क्रिप्ट और कई अन्य कार्यान्वयन एक उत्पन्न करते हैं।)

    ```markdown
    1. fee
    2. fie

    - foe
    - fum
    ```

8.  इनलाइन संरचना के मार्करों के लिए प्राथमिकता नियम क्या हैं?
    उदाहरण के लिए, क्या निम्नलिखित एक मान्य लिंक है, या कोड स्पैन को
    प्राथमिकता मिलती है?

    ```markdown
    [a backtick (`)](/url) and [another backtick (`)](/url).
    ```

9.  ज़ोर और strong ज़ोर के मार्करों के लिए प्राथमिकता नियम क्या हैं? उदाहरण के लिए, निम्नलिखित को कैसे पार्स किया जाना चाहिए?

    ```markdown
    *foo *bar* baz*
    ```

10. ब्लॉक-स्तरीय और इनलाइन-स्तरीय संरचना के बीच प्राथमिकता नियम क्या हैं? उदाहरण के लिए, निम्नलिखित को कैसे पार्स किया जाना चाहिए?

    ```markdown
    - `a long code span can contain a hyphen like this
      - and it can screw things up`
    ```

11. क्या सूची आइटम में सेक्शन हेडिंग शामिल हो सकती हैं? (`Markdown.pl` इसकी
    अनुमति नहीं देता है, लेकिन blockquotes को हेडिंग शामिल करने की अनुमति देता है।)

    ```markdown
    - # Heading
    ```

12. क्या सूची आइटम खाली हो सकते हैं?

    ```markdown
    - a
    -
    - b
    ```

13. क्या लिंक संदर्भों को ब्लॉक कोट्स या सूची आइटम के अंदर परिभाषित किया जा सकता है?

    ```markdown
    > Blockquote [foo].
    >
    > [foo]: /url
    ```

14. यदि एक ही संदर्भ के लिए एकाधिक परिभाषाएं हैं, तो किसे प्राथमिकता मिलती है?

    ```markdown
    [foo]: /url1
    [foo]: /url2

    [foo][]
    ```

विनिर्देश की अनुपस्थिति में, शुरुआती कार्यान्वयनकर्ताओं ने इन अस्पष्टताओं को हल करने के लिए `Markdown.pl` से परामर्श किया। लेकिन `Markdown.pl` काफी buggy था, और कई मामलों में स्पष्ट रूप से खराब परिणाम दिए, इसलिए यह विनिर्देश के लिए एक संतोषजनक प्रतिस्थापन नहीं था।

क्योंकि कोई स्पष्ट विनिर्देश नहीं है, कार्यान्वयन काफी विचलित हो गए हैं। परिणामस्वरूप, उपयोगकर्ता अक्सर आश्चर्यचकित होते हैं कि एक दस्तावेज़ जो एक सिस्टम (जैसे, GitHub wiki) पर एक तरह से रेंडर होता है, दूसरे पर अलग तरह से रेंडर होता है (जैसे, pandoc का उपयोग करके docbook में परिवर्तित करना)। मामले को और खराब करने के लिए, क्योंकि Markdown में कुछ भी "syntax error" के रूप में नहीं गिना जाता है, विचलन अक्सर तुरंत खोजा नहीं जाता है।

## इस दस्तावेज़ के बारे में

यह दस्तावेज़ Markdown सिंटैक्स को स्पष्ट रूप से निर्दिष्ट करने का प्रयास करता है। इसमें साथ-साथ Markdown और HTML के साथ कई उदाहरण शामिल हैं। ये अनुरूपता परीक्षणों के रूप में दोगुना करने के लिए हैं। एक साथ वाली स्क्रिप्ट `spec_tests.py` का उपयोग किसी भी Markdown प्रोग्राम के खिलाफ परीक्षण चलाने के लिए किया जा सकता है:

    python test/spec_tests.py --spec spec.txt --program PROGRAM

चूंकि यह दस्तावेज़ बताता है कि Markdown को abstract syntax tree में कैसे पार्स किया जाना है, इसलिए HTML के बजाय syntax tree के abstract प्रतिनिधित्व का उपयोग करना समझ में आता। लेकिन HTML उन संरचनात्मक भेदों को दर्शाने में सक्षम है जिन्हें हमें बनाने की आवश्यकता है, और परीक्षणों के लिए HTML का चुनाव abstract syntax tree renderer लिखे बिना कार्यान्वयन के खिलाफ परीक्षण चलाना संभव बनाता है।

यह दस्तावेज़ एक टेक्स्ट फ़ाइल, `spec.txt` से उत्पन्न किया गया है, जो साथ-साथ परीक्षणों के लिए एक छोटे एक्सटेंशन के साथ Markdown में लिखा गया है। स्क्रिप्ट `tools/makespec.py` का उपयोग `spec.txt` को HTML या CommonMark में बदलने के लिए किया जा सकता है (जिसे फिर अन्य फ़ॉर्मेट में परिवर्तित किया जा सकता है)।

उदाहरणों में, `→` वर्ण का उपयोग टैब का प्रतिनिधित्व करने के लिए किया जाता है।

# प्रारंभिक

## वर्ण और लाइनें

[वर्णों] का कोई भी अनुक्रम एक मान्य CommonMark दस्तावेज़ है।

एक [character](@) एक Unicode code point है। यद्यपि कुछ code points (उदाहरण के लिए, combining accents) सहज अर्थ में वर्णों से संबंधित नहीं हैं, सभी code points इस विनिर्देश के उद्देश्यों के लिए वर्णों के रूप में गिने जाते हैं।

यह विनिर्देश encoding निर्दिष्ट नहीं करता है; यह लाइनों को bytes के बजाय [वर्णों] से बना मानता है। एक अनुरूप पार्सर एक निश्चित encoding तक सीमित हो सकता है।

एक [line](@) newline (`U+000A`) या carriage return (`U+000D`) के अलावा शून्य या अधिक [वर्णों] का एक अनुक्रम है, जिसके बाद एक [line ending] या फ़ाइल का अंत होता है।

एक [line ending](@) एक newline (`U+000A`), एक carriage return (`U+000D`) है जो newline के बाद नहीं है, या एक carriage return और उसके बाद newline है।

एक लाइन जिसमें कोई वर्ण नहीं है, या एक लाइन जिसमें केवल spaces (`U+0020`) या tabs (`U+0009`) हैं, को [blank line](@) कहा जाता है।

वर्ण वर्गों की निम्नलिखित परिभाषाओं का उपयोग इस विनिर्देश में किया जाएगा:

एक [whitespace character](@) एक space (`U+0020`), tab (`U+0009`), newline (`U+000A`), line tabulation (`U+000B`), form feed (`U+000C`), या carriage return (`U+000D`) है।

[Whitespace](@) एक या अधिक [whitespace characters] का एक अनुक्रम है।

एक [Unicode whitespace character](@) Unicode `Zs` सामान्य श्रेणी में कोई भी code point है, या एक tab (`U+0009`), carriage return (`U+000D`), newline (`U+000A`), या form feed (`U+000C`) है।

[Unicode whitespace](@) एक या अधिक [Unicode whitespace characters] का एक अनुक्रम है।

एक [space](@) `U+0020` है।

एक [non-whitespace character](@) कोई भी वर्ण है जो [whitespace character] नहीं है।

एक [ASCII punctuation character](@) `!`, `"`, `#`, `$`, `%`, `&`, `'`, `(`, `)`, `*`, `+`, `,`, `-`, `.`, `/` (U+0021–2F), `:`, `;`, `<`, `=`, `>`, `?`, `@` (U+003A–0040), `[`, `\`, `]`, `^`, `_`, `` ` `` (U+005B–0060), `{`, `|`, `}`, या `~` (U+007B–007E) है।

एक [punctuation character](@) एक [ASCII punctuation character] है या सामान्य Unicode श्रेणियों `Pc`, `Pd`, `Pe`, `Pf`, `Pi`, `Po`, या `Ps` में कुछ भी है।

## टैब्स

लाइनों में टैब्स को [spaces] में विस्तारित नहीं किया जाता है। हालांकि, उन संदर्भों में जहां whitespace ब्लॉक संरचना को परिभाषित करने में मदद करता है, टैब्स वैसे ही व्यवहार करते हैं जैसे कि उन्हें 4 वर्णों के tab stop के साथ spaces से बदल दिया गया हो।

इस प्रकार, उदाहरण के लिए, एक इंडेंटेड कोड ब्लॉक में चार spaces के बजाय एक टैब का उपयोग किया जा सकता है। (हालांकि, ध्यान दें कि आंतरिक टैब्स को शाब्दिक टैब्स के रूप में पास किया जाता है, spaces में विस्तारित नहीं किया जाता है।)

```example
→foo→baz→→bim
.
<pre><code>foo→baz→→bim
</code></pre>
```

```example
  →foo→baz→→bim
.
<pre><code>foo→baz→→bim
</code></pre>
```

```example
    a→a
    ὐ→a
.
<pre><code>a→a
ὐ→a
</code></pre>
```

निम्नलिखित उदाहरण में, एक सूची आइटम का कंटिन्यूएशन पैराग्राफ एक टैब के साथ इंडेंट किया गया है; इसका वही प्रभाव होता है जो चार spaces के साथ इंडेंटेशन का होता है:

```example
  - foo

→bar
.
<ul>
<li>
<p>foo</p>
<p>bar</p>
</li>
</ul>
```

```example
- foo

→→bar
.
<ul>
<li>
<p>foo</p>
<pre><code>  bar
</code></pre>
</li>
</ul>
```

सामान्य रूप से ब्लॉक कोट शुरू करने वाले `>` के बाद वैकल्पिक रूप से एक space हो सकता है, जिसे सामग्री का हिस्सा नहीं माना जाता है। निम्नलिखित मामले में `>` के बाद एक टैब है, जिसे वैसे ही माना जाता है जैसे कि इसे तीन spaces में विस्तारित किया गया हो। चूंकि इनमें से एक space को delimiter का हिस्सा माना जाता है, `foo` को ब्लॉक कोट संदर्भ के अंदर छह spaces इंडेंट माना जाता है, इसलिए हमें दो spaces से शुरू होने वाला एक इंडेंटेड कोड ब्लॉक मिलता है।

```example
>→→foo
.
<blockquote>
<pre><code>  foo
</code></pre>
</blockquote>
```

```example
-→→foo
.
<ul>
<li>
<pre><code>  foo
</code></pre>
</li>
</ul>
```

```example
    foo
→bar
.
<pre><code>foo
bar
</code></pre>
```

```example
 - foo
   - bar
→ - baz
.
<ul>
<li>foo
<ul>
<li>bar
<ul>
<li>baz</li>
</ul>
</li>
</ul>
</li>
</ul>
```

```example
#→Foo
.
<h1>Foo</h1>
```

```example
*→*→*→
.
<hr />
```

## असुरक्षित वर्ण

सुरक्षा कारणों से, Unicode वर्ण `U+0000` को REPLACEMENT CHARACTER (`U+FFFD`) से बदला जाना चाहिए।

# ब्लॉक्स और इनलाइन्स

हम एक दस्तावेज़ को [blocks](@)---संरचनात्मक तत्वों जैसे पैराग्राफ, ब्लॉक कोटेशन, सूचियाँ, हेडिंग्स, नियम, और कोड ब्लॉक्स के एक अनुक्रम के रूप में सोच सकते हैं। कुछ ब्लॉक्स (जैसे ब्लॉक कोट्स और सूची आइटम्स) अन्य ब्लॉक्स शामिल करते हैं; अन्य (जैसे हेडिंग्स और पैराग्राफ) [inline](@) सामग्री---टेक्स्ट, लिंक्स, ज़ोर दिया गया टेक्स्ट, छवियाँ, कोड स्पैन, इत्यादि शामिल करते हैं।

## प्राथमिकता

ब्लॉक संरचना के संकेतक हमेशा इनलाइन संरचना के संकेतकों पर प्राथमिकता लेते हैं। इसलिए, उदाहरण के लिए, निम्नलिखित दो आइटम्स वाली एक सूची है, न कि एक कोड स्पैन युक्त एक आइटम वाली सूची:

```example
- `one
- two`
.
<ul>
<li>`one</li>
<li>two`</li>
</ul>
```

इसका अर्थ है कि पार्सिंग दो चरणों में आगे बढ़ सकती है: पहले, दस्तावेज़ की ब्लॉक संरचना को पहचाना जा सकता है; दूसरा, पैराग्राफ, हेडिंग्स, और अन्य ब्लॉक कंस्ट्रक्ट्स के अंदर टेक्स्ट लाइनों को इनलाइन संरचना के लिए पार्स किया जा सकता है। दूसरे चरण को लिंक संदर्भ परिभाषाओं के बारे में जानकारी की आवश्यकता होती है जो केवल पहले चरण के अंत में उपलब्ध होगी। ध्यान दें कि पहले चरण को अनुक्रम में लाइनों को प्रोसेस करने की आवश्यकता है, लेकिन दूसरे को समानांतर किया जा सकता है, क्योंकि एक ब्लॉक एलिमेंट की इनलाइन पार्सिंग किसी अन्य की इनलाइन पार्सिंग को प्रभावित नहीं करती है।

## कंटेनर ब्लॉक्स और लीफ ब्लॉक्स

हम ब्लॉक्स को दो प्रकारों में विभाजित कर सकते हैं:
[container blocks](@),
जो अन्य ब्लॉक्स शामिल कर सकते हैं, और [leaf blocks](@),
जो नहीं कर सकते।

# लीफ ब्लॉक्स

यह अनुभाग Markdown दस्तावेज़ बनाने वाले विभिन्न प्रकार के लीफ ब्लॉक का वर्णन करता है।

## थीमैटिक ब्रेक्स

0-3 spaces के इंडेंटेशन से युक्त एक लाइन, जिसके बाद तीन या अधिक मिलते-जुलते `-`, `_`, या `*` वर्णों का एक अनुक्रम हो, प्रत्येक के बाद वैकल्पिक रूप से कोई भी संख्या में spaces या tabs हों, एक [thematic break](@) बनाता है।

```example
***
---
___
.
<hr />
<hr />
<hr />
```

गलत वर्ण:

```example
+++
.
<p>+++</p>
```

```example
===
.
<p>===</p>
```

पर्याप्त वर्ण नहीं:

```example
--
**
__
.
<p>--
**
__</p>
```

एक से तीन spaces इंडेंट की अनुमति है:

```example
 ***
  ***
   ***
.
<hr />
<hr />
<hr />
```

चार spaces बहुत अधिक हैं:

```example
    ***
.
<pre><code>***
</code></pre>
```

```example
Foo
    ***
.
<p>Foo
***</p>
```

तीन से अधिक वर्णों का उपयोग किया जा सकता है:

```example
_____________________________________
.
<hr />
```

वर्णों के बीच spaces की अनुमति है:

```example
 - - -
.
<hr />
```

```example
 **  * ** * ** * **
.
<hr />
```

```example
-     -      -      -
.
<hr />
```

अंत में spaces की अनुमति है:

```example
- - - -
.
<hr />
```

हालांकि, लाइन में कोई अन्य वर्ण नहीं हो सकते:

```example
_ _ _ _ a

a------

---a---
.
<p>_ _ _ _ a</p>
<p>a------</p>
<p>---a---</p>
```

यह आवश्यक है कि सभी [non-whitespace characters] समान हों।
इसलिए, यह थीमैटिक ब्रेक नहीं है:

```example
 *-*
.
<p><em>-</em></p>
```

थीमैटिक ब्रेक्स को पहले या बाद में खाली लाइनों की आवश्यकता नहीं है:

```example
- foo
***
- bar
.
<ul>
<li>foo</li>
</ul>
<hr />
<ul>
<li>bar</li>
</ul>
```

थीमैटिक ब्रेक्स एक पैराग्राफ को बाधित कर सकते हैं:

```example
Foo
***
bar
.
<p>Foo</p>
<hr />
<p>bar</p>
```

यदि डैश की एक लाइन जो थीमैटिक ब्रेक होने के लिए उपरोक्त शर्तों को पूरा करती है, उसे [setext heading] की अंडरलाइन के रूप में भी समझा जा सकता है, तो [setext heading] के रूप में व्याख्या को प्राथमिकता मिलती है। इस प्रकार, उदाहरण के लिए, यह एक setext heading है, थीमैटिक ब्रेक के बाद एक पैराग्राफ नहीं:

```example
Foo
---
bar
.
<h2>Foo</h2>
<p>bar</p>
```

जब एक लाइन की थीमैटिक ब्रेक और सूची आइटम दोनों संभावित व्याख्याएं हों, तो थीमैटिक ब्रेक को प्राथमिकता मिलती है:

```example
* Foo
* * *
* Bar
.
<ul>
<li>Foo</li>
</ul>
<hr />
<ul>
<li>Bar</li>
</ul>
```

यदि आप एक सूची आइटम में थीमैटिक ब्रेक चाहते हैं, तो एक अलग बुलेट का उपयोग करें:

```example
- Foo
- * * *
.
<ul>
<li>Foo</li>
<li>
<hr />
</li>
</ul>
```

## ATX हेडिंग्स

एक [ATX heading](@) इनलाइन सामग्री के रूप में पार्स किए गए वर्णों की एक स्ट्रिंग से बना है, जो 1--6 unescaped `#` वर्णों के एक शुरुआती अनुक्रम और किसी भी संख्या के unescaped `#` वर्णों के एक वैकल्पिक समापन अनुक्रम के बीच होती है। `#` वर्णों के शुरुआती अनुक्रम के बाद एक [space] या लाइन के अंत का पालन होना चाहिए। `#`s के वैकल्पिक समापन अनुक्रम से पहले एक [space] होना चाहिए और केवल spaces का पालन हो सकता है। शुरुआती `#` वर्ण को 0-3 spaces इंडेंट किया जा सकता है। हेडिंग की raw सामग्री को इनलाइन सामग्री के रूप में पार्स करने से पहले अग्रणी और अनुगामी spaces को हटा दिया जाता है। हेडिंग स्तर शुरुआती अनुक्रम में `#` वर्णों की संख्या के बराबर है।

सरल हेडिंग्स:

```example
# foo
## foo
### foo
#### foo
##### foo
###### foo
.
<h1>foo</h1>
<h2>foo</h2>
<h3>foo</h3>
<h4>foo</h4>
<h5>foo</h5>
<h6>foo</h6>
```

छह से अधिक `#` वर्ण हेडिंग नहीं है:

```example
####### foo
.
<p>####### foo</p>
```

`#` वर्णों और हेडिंग की सामग्री के बीच कम से कम एक space आवश्यक है, जब तक कि हेडिंग खाली न हो। ध्यान दें कि कई कार्यान्वयन वर्तमान में space की आवश्यकता नहीं करते हैं। हालांकि, [मूल ATX कार्यान्वयन](http://www.aaronsw.com/2002/atx/atx.py) द्वारा space आवश्यक था, और यह निम्नलिखित जैसी चीजों को हेडिंग के रूप में पार्स होने से रोकने में मदद करता है:

```example
#5 bolt

#hashtag
.
<p>#5 bolt</p>
<p>#hashtag</p>
```

यह हेडिंग नहीं है, क्योंकि पहला `#` escaped है:

```example
\## foo
.
<p>## foo</p>
```

सामग्री को इनलाइन के रूप में पार्स किया जाता है:

```example
# foo *bar* \*baz\*
.
<h1>foo <em>bar</em> *baz*</h1>
```

इनलाइन सामग्री को पार्स करने में अग्रणी और अनुगामी [whitespace] को नजरअंदाज किया जाता है:

```example
#                  foo
.
<h1>foo</h1>
```

एक से तीन spaces इंडेंटेशन की अनुमति है:

```example
 ### foo
  ## foo
   # foo
.
<h3>foo</h3>
<h2>foo</h2>
<h1>foo</h1>
```

चार spaces बहुत अधिक हैं:

```example
    # foo
.
<pre><code># foo
</code></pre>
```

```example
foo
    # bar
.
<p>foo
# bar</p>
```

`#` वर्णों का एक समापन अनुक्रम वैकल्पिक है:

```example
## foo ##
  ###   bar    ###
.
<h2>foo</h2>
<h3>bar</h3>
```

यह शुरुआती अनुक्रम की लंबाई के समान होना आवश्यक नहीं है:

```example
# foo ##################################
##### foo ##
.
<h1>foo</h1>
<h5>foo</h5>
```

समापन अनुक्रम के बाद spaces की अनुमति है:

```example
### foo ###
.
<h3>foo</h3>
```

`#` वर्णों का एक अनुक्रम जिसके बाद [spaces] के अलावा कुछ भी हो, वह समापन अनुक्रम नहीं है, बल्कि हेडिंग की सामग्री के हिस्से के रूप में गिना जाता है:

```example
### foo ### b
.
<h3>foo ### b</h3>
```

समापन अनुक्रम से पहले एक space होना चाहिए:

```example
# foo#
.
<h1>foo#</h1>
```

Backslash-escaped `#` वर्ण समापन अनुक्रम के हिस्से के रूप में नहीं गिने जाते:

```example
### foo \###
## foo #\##
# foo \#
.
<h3>foo ###</h3>
<h2>foo ###</h2>
<h1>foo #</h1>
```

ATX हेडिंग्स को आसपास की सामग्री से खाली लाइनों द्वारा अलग किया जाना आवश्यक नहीं है, और वे पैराग्राफ को बाधित कर सकती हैं:

```example
****
## foo
****
.
<hr />
<h2>foo</h2>
<hr />
```

```example
Foo bar
# baz
Bar foo
.
<p>Foo bar</p>
<h1>baz</h1>
<p>Bar foo</p>
```

ATX हेडिंग्स खाली हो सकती हैं:

```example
##
#
### ###
.
<h2></h2>
<h1></h1>
<h3></h3>
```

## Setext हेडिंग्स

एक [setext heading](@) टेक्स्ट की एक या अधिक लाइनों से बना है, प्रत्येक में कम से कम एक [non-whitespace character] होता है, 3 से अधिक spaces इंडेंटेशन नहीं, जिसके बाद एक [setext heading underline] होती है। टेक्स्ट की लाइनें ऐसी होनी चाहिए कि, यदि उनके बाद setext heading underline न हो, तो उन्हें एक पैराग्राफ के रूप में व्याख्यायित किया जाएगा: उन्हें [code fence], [ATX heading][ATX headings], [block quote][block quotes], [thematic break][thematic breaks], [list item][list items], या [HTML block][HTML blocks] के रूप में व्याख्यायित नहीं किया जा सकता है।

एक [setext heading underline](@) `=` वर्णों का एक अनुक्रम या `-` वर्णों का एक अनुक्रम है, जिसमें 3 से अधिक spaces का इंडेंटेशन नहीं और कोई भी संख्या में अनुगामी spaces या tabs हों।

हेडिंग एक स्तर 1 हेडिंग है यदि [setext heading underline] में `=` वर्णों का उपयोग किया जाता है, और एक स्तर 2 हेडिंग यदि `-` वर्णों का उपयोग किया जाता है। हेडिंग की सामग्री पहले की टेक्स्ट लाइनों को CommonMark इनलाइन सामग्री के रूप में पार्स करने का परिणाम है।

सामान्य रूप से, एक setext heading को पहले या बाद में खाली लाइन की आवश्यकता नहीं है। हालांकि, यह एक पैराग्राफ को बाधित नहीं कर सकती है, इसलिए जब एक setext heading एक पैराग्राफ के बाद आती है, तो उनके बीच एक खाली लाइन की आवश्यकता होती है।

सरल उदाहरण:

```example
Foo *bar*
=========

Foo *bar*
---------
.
<h1>Foo <em>bar</em></h1>
<h2>Foo <em>bar</em></h2>
```

हेडर की सामग्री एक से अधिक लाइनों में फैल सकती है:

```example
Foo *bar
baz*
====
.
<h1>Foo <em>bar
baz</em></h1>
```

सामग्री हेडिंग की raw सामग्री को इनलाइन के रूप में पार्स करने का परिणाम है। हेडिंग की raw सामग्री लाइनों को जोड़कर और प्रारंभिक और अंतिम [whitespace] को हटाकर बनाई जाती है।

```example
  Foo *bar
baz*→
====
.
<h1>Foo <em>bar
baz</em></h1>
```

अंडरलाइनिंग किसी भी लंबाई की हो सकती है:

```example
Foo
-------------------------

Foo
=
.
<h2>Foo</h2>
<h1>Foo</h1>
```

हेडिंग सामग्री को तीन spaces तक इंडेंट किया जा सकता है, और अंडरलाइनिंग के साथ लाइन अप करने की आवश्यकता नहीं है:

```example
   Foo
---

  Foo
-----

  Foo
  ===
.
<h2>Foo</h2>
<h2>Foo</h2>
<h1>Foo</h1>
```

चार spaces इंडेंट बहुत अधिक है:

```example
    Foo
    ---

    Foo
---
.
<pre><code>Foo
---

Foo
</code></pre>
<hr />
```

setext heading underline को तीन spaces तक इंडेंट किया जा सकता है, और इसमें अनुगामी spaces हो सकते हैं:

```example
Foo
   ----
.
<h2>Foo</h2>
```

चार spaces बहुत अधिक हैं:

```example
Foo
    ---
.
<p>Foo
---</p>
```

setext heading underline में आंतरिक spaces नहीं हो सकते:

```example
Foo
= =

Foo
--- -
.
<p>Foo
= =</p>
<p>Foo</p>
<hr />
```

सामग्री लाइन में अनुगामी spaces लाइन ब्रेक का कारण नहीं बनते:

```example
Foo
-----
.
<h2>Foo</h2>
```

न ही अंत में एक backslash:

```example
Foo\
----
.
<h2>Foo\</h2>
```

चूंकि ब्लॉक संरचना के संकेतक इनलाइन संरचना के संकेतकों पर प्राथमिकता लेते हैं, निम्नलिखित setext हेडिंग्स हैं:

```example
`Foo
----
`

<a title="a lot
---
of dashes"/>
.
<h2>`Foo</h2>
<p>`</p>
<h2>&lt;a title=&quot;a lot</h2>
<p>of dashes&quot;/&gt;</p>
```

setext heading underline एक सूची आइटम या ब्लॉक कोट में एक [lazy continuation line] नहीं हो सकती:

```example
> Foo
---
.
<blockquote>
<p>Foo</p>
</blockquote>
<hr />
```

```example
> foo
bar
===
.
<blockquote>
<p>foo
bar
===</p>
</blockquote>
```

```example
- Foo
---
.
<ul>
<li>Foo</li>
</ul>
<hr />
```

एक पैराग्राफ और उसके बाद की setext heading के बीच एक खाली लाइन की आवश्यकता है, क्योंकि अन्यथा पैराग्राफ हेडिंग की सामग्री का हिस्सा बन जाता है:

```example
Foo
Bar
---
.
<h2>Foo
Bar</h2>
```

लेकिन सामान्य रूप से setext हेडिंग्स के पहले या बाद में खाली लाइन आवश्यक नहीं है:

```example
---
Foo
---
Bar
---
Baz
.
<hr />
<h2>Foo</h2>
<h2>Bar</h2>
<p>Baz</p>
```

Setext हेडिंग्स खाली नहीं हो सकतीं:

```example

====
.
<p>====</p>
```

Setext heading टेक्स्ट लाइनों को पैराग्राफ के अलावा ब्लॉक कंस्ट्रक्ट्स के रूप में व्याख्यायित नहीं किया जाना चाहिए। इसलिए, इन उदाहरणों में डैश की लाइन को थीमैटिक ब्रेक के रूप में व्याख्यायित किया जाता है:

```example
---
---
.
<hr />
<hr />
```

```example
- foo
-----
.
<ul>
<li>foo</li>
</ul>
<hr />
```

```example
    foo
---
.
<pre><code>foo
</code></pre>
<hr />
```

```example
> foo
-----
.
<blockquote>
<p>foo</p>
</blockquote>
<hr />
```

यदि आप `> foo` को इसके शाब्दिक टेक्स्ट के रूप में एक हेडिंग चाहते हैं, तो आप backslash escapes का उपयोग कर सकते हैं:

```example
\> foo
------
.
<h2>&gt; foo</h2>
```

**संगतता नोट:** अधिकांश मौजूदा Markdown कार्यान्वयन setext हेडिंग्स के टेक्स्ट को कई लाइनों में फैलाने की अनुमति नहीं देते हैं। लेकिन इसकी व्याख्या कैसे करें इस पर कोई आम सहमति नहीं है

```markdown
Foo
bar

---

baz
```

कोई चार अलग व्याख्याएं पा सकता है:

1. पैराग्राफ "Foo", हेडिंग "bar", पैराग्राफ "baz"
2. पैराग्राफ "Foo bar", थीमैटिक ब्रेक, पैराग्राफ "baz"
3. पैराग्राफ "Foo bar --- baz"
4. हेडिंग "Foo bar", पैराग्राफ "baz"

हम व्याख्या 4 को सबसे स्वाभाविक पाते हैं, और व्याख्या 4 CommonMark की अभिव्यंजक शक्ति को बहुपंक्ति हेडिंग्स की अनुमति देकर बढ़ाती है। जो लेखक व्याख्या 1 चाहते हैं वे पहले पैराग्राफ के बाद एक खाली लाइन डाल सकते हैं:

```example
Foo

bar
---
baz
.
<p>Foo</p>
<h2>bar</h2>
<p>baz</p>
```

जो लेखक व्याख्या 2 चाहते हैं वे थीमैटिक ब्रेक के आसपास खाली लाइनें डाल सकते हैं,

```example
Foo
bar

---

baz
.
<p>Foo
bar</p>
<hr />
<p>baz</p>
```

या एक ऐसे थीमैटिक ब्रेक का उपयोग करें जिसे [setext heading underline] के रूप में नहीं गिना जा सकता, जैसे कि

```example
Foo
bar
* * *
baz
.
<p>Foo
bar</p>
<hr />
<p>baz</p>
```

जो लेखक व्याख्या 3 चाहते हैं वे backslash escapes का उपयोग कर सकते हैं:

```example
Foo
bar
\---
baz
.
<p>Foo
bar
---
baz</p>
```

## इंडेंटेड कोड ब्लॉक्स

एक [indented code block](@) एक या अधिक [indented chunks] से बना है जो खाली लाइनों द्वारा अलग किए गए हैं। एक [indented chunk](@) गैर-खाली लाइनों का एक अनुक्रम है, प्रत्येक चार या अधिक spaces इंडेंट है। कोड ब्लॉक की सामग्री लाइनों की शाब्दिक सामग्री है, जिसमें अनुगामी [line endings] शामिल हैं, घटा चार spaces का इंडेंटेशन। एक इंडेंटेड कोड ब्लॉक में कोई [info string] नहीं है।

एक इंडेंटेड कोड ब्लॉक एक पैराग्राफ को बाधित नहीं कर सकता, इसलिए एक पैराग्राफ और उसके बाद के इंडेंटेड कोड ब्लॉक के बीच एक खाली लाइन होनी चाहिए। (हालांकि, एक कोड ब्लॉक और उसके बाद के पैराग्राफ के बीच खाली लाइन की आवश्यकता नहीं है।)

```example
    a simple
      indented code block
.
<pre><code>a simple
  indented code block
</code></pre>
```

यदि इंडेंटेशन की व्याख्या एक कोड ब्लॉक के रूप में और यह संकेत के रूप में कि सामग्री एक [list item][list items] से संबंधित है, के बीच कोई अस्पष्टता है, तो सूची आइटम व्याख्या को प्राथमिकता मिलती है:

```example
  - foo

    bar
.
<ul>
<li>
<p>foo</p>
<p>bar</p>
</li>
</ul>
```

```example
1.  foo

    - bar
.
<ol>
<li>
<p>foo</p>
<ul>
<li>bar</li>
</ul>
</li>
</ol>
```

कोड ब्लॉक की सामग्री शाब्दिक टेक्स्ट है, और Markdown के रूप में पार्स नहीं होती:

```example
    <a/>
    *hi*

    - one
.
<pre><code>&lt;a/&gt;
*hi*

- one
</code></pre>
```

यहां हमारे पास खाली लाइनों द्वारा अलग किए गए तीन chunks हैं:

```example
    chunk1

    chunk2



    chunk3
.
<pre><code>chunk1

chunk2



chunk3
</code></pre>
```

चार से परे कोई भी प्रारंभिक spaces सामग्री में शामिल किए जाएंगे, यहां तक कि आंतरिक खाली लाइनों में भी:

```example
    chunk1

      chunk2
.
<pre><code>chunk1

  chunk2
</code></pre>
```

एक इंडेंटेड कोड ब्लॉक एक पैराग्राफ को बाधित नहीं कर सकता। (यह hanging indents और इसी तरह की चीजों की अनुमति देता है।)

```example
Foo
    bar

.
<p>Foo
bar</p>
```

हालांकि, चार से कम अग्रणी spaces वाली कोई भी गैर-खाली लाइन तुरंत कोड ब्लॉक को समाप्त कर देती है। इसलिए इंडेंटेड कोड के तुरंत बाद एक पैराग्राफ हो सकता है:

```example
    foo
bar
.
<pre><code>foo
</code></pre>
<p>bar</p>
```

और इंडेंटेड कोड अन्य प्रकार के ब्लॉक्स के तुरंत पहले और बाद में हो सकता है:

```example
# Heading
    foo
Heading
------
    foo
----
.
<h1>Heading</h1>
<pre><code>foo
</code></pre>
<h2>Heading</h2>
<pre><code>foo
</code></pre>
<hr />
```

पहली लाइन को चार spaces से अधिक इंडेंट किया जा सकता है:

```example
        foo
    bar
.
<pre><code>    foo
bar
</code></pre>
```

इंडेंटेड कोड ब्लॉक से पहले या बाद की खाली लाइनें इसमें शामिल नहीं हैं:

```example


    foo


.
<pre><code>foo
</code></pre>
```

अनुगामी spaces कोड ब्लॉक की सामग्री में शामिल हैं:

```example
    foo
.
<pre><code>foo
</code></pre>
```

## फ़ेंस्ड कोड ब्लॉक्स

एक [code fence](@) कम से कम तीन लगातार backtick वर्णों (`` ` ``) या tildes (`~`) का एक अनुक्रम है। (Tildes और backticks को मिलाया नहीं जा सकता।) एक [fenced code block](@) एक code fence से शुरू होता है, जो तीन से अधिक spaces इंडेंट नहीं है।

शुरुआती code fence वाली लाइन में वैकल्पिक रूप से code fence के बाद कुछ टेक्स्ट हो सकता है; इसे अग्रणी और अनुगामी whitespace से ट्रिम किया जाता है और इसे [info string](@) कहा जाता है। यदि [info string] एक backtick fence के बाद आती है, तो इसमें कोई backtick वर्ण नहीं हो सकते। (इस प्रतिबंध का कारण यह है कि अन्यथा कुछ इनलाइन कोड को गलती से एक fenced code block की शुरुआत के रूप में व्याख्यायित किया जाएगा।)

कोड ब्लॉक की सामग्री में सभी बाद की लाइनें शामिल होती हैं, जब तक कि समान प्रकार का समापन [code fence] नहीं आता जिससे कोड ब्लॉक शुरू हुआ था (backticks या tildes), और कम से कम उतने backticks या tildes जितने शुरुआती code fence में थे। यदि अग्रणी code fence N spaces इंडेंट है, तो सामग्री की प्रत्येक लाइन से N spaces तक का इंडेंटेशन हटाया जाता है (यदि मौजूद हो)। (यदि सामग्री लाइन इंडेंट नहीं है, तो इसे अपरिवर्तित संरक्षित किया जाता है। यदि यह N spaces से कम इंडेंट है, तो सभी इंडेंटेशन हटाया जाता है।)

समापन code fence को तीन spaces तक इंडेंट किया जा सकता है, और केवल spaces का पालन हो सकता है, जिन्हें नजरअंदाज किया जाता है। यदि युक्त ब्लॉक (या दस्तावेज़) के अंत तक पहुंच जाता है और कोई समापन code fence नहीं मिलता है, तो कोड ब्लॉक में शुरुआती code fence के बाद की सभी लाइनें युक्त ब्लॉक (या दस्तावेज़) के अंत तक शामिल होती हैं। (एक वैकल्पिक spec को backtracking की आवश्यकता होगी यदि समापन code fence नहीं मिलता है। लेकिन यह पार्सिंग को बहुत कम कुशल बनाता है, और यहां वर्णित व्यवहार में कोई वास्तविक कमी नहीं लगती है।)

एक fenced code block एक पैराग्राफ को बाधित कर सकता है, और इसे पहले या बाद में खाली लाइन की आवश्यकता नहीं है।

code fence की सामग्री को शाब्दिक टेक्स्ट के रूप में माना जाता है, इनलाइन के रूप में पार्स नहीं किया जाता। [info string] के पहले शब्द का उपयोग आमतौर पर कोड नमूने की भाषा निर्दिष्ट करने के लिए किया जाता है, और `code` टैग के `class` एट्रिब्यूट में रेंडर किया जाता है। हालांकि, यह spec [info string] के किसी विशेष उपचार को अनिवार्य नहीं करता है।

यहां backticks के साथ एक सरल उदाहरण है:

````example
```
<
 >
```
.
<pre><code>&lt;
 &gt;
</code></pre>
````

Tildes के साथ:

```example
~~~
<
 >
~~~
.
<pre><code>&lt;
 &gt;
</code></pre>
```

तीन से कम backticks पर्याप्त नहीं हैं:

```example
``
foo
``
.
<p><code>foo</code></p>
```

समापन code fence को शुरुआती fence के समान वर्ण का उपयोग करना चाहिए:

````example
```
aaa
~~~
```
.
<pre><code>aaa
~~~
</code></pre>
````

````example
~~~
aaa
```
~~~
.
<pre><code>aaa
```
</code></pre>
````

समापन code fence कम से कम शुरुआती fence जितना लंबा होना चाहिए:

```````example
````
aaa
```
``````
.
<pre><code>aaa
```
</code></pre>
```````

```example
~~~~
aaa
~~~
~~~~
.
<pre><code>aaa
~~~
</code></pre>
```

बंद न किए गए कोड ब्लॉक्स दस्तावेज़ के अंत (या युक्त [block quote][block quotes] या [list item][list items]) द्वारा बंद किए जाते हैं:

````example
```
.
<pre><code></code></pre>
````

``````example
`````

```
aaa
.
<pre><code>
```
aaa
</code></pre>
``````

````example
> ```
> aaa

bbb
.
<blockquote>
<pre><code>aaa
</code></pre>
</blockquote>
<p>bbb</p>
````

A code block can have all empty lines as its content:

````example
```


```
.
<pre><code>

</code></pre>
````

A code block can be empty:

````example
```
```
.
<pre><code></code></pre>
````

Fences can be indented. If the opening fence is indented,
content lines will have equivalent opening indentation removed,
if present:

````example
 ```
 aaa
aaa
```
.
<pre><code>aaa
aaa
</code></pre>
````

````example
  ```
aaa
  aaa
aaa
  ```
.
<pre><code>aaa
aaa
aaa
</code></pre>
````

````example
   ```
   aaa
    aaa
  aaa
   ```
.
<pre><code>aaa
 aaa
aaa
</code></pre>
````

चार spaces इंडेंटेशन एक इंडेंटेड कोड ब्लॉक बनाता है:

````example
    ```
    aaa
    ```
.
<pre><code>```
aaa
```
</code></pre>
````

समापन fences को 0-3 spaces द्वारा इंडेंट किया जा सकता है, और उनके इंडेंटेशन को शुरुआती fence के साथ मेल खाने की आवश्यकता नहीं है:

````example
```
aaa
  ```
.
<pre><code>aaa
</code></pre>
````

````example
   ```
aaa
  ```
.
<pre><code>aaa
</code></pre>
````

यह समापन fence नहीं है, क्योंकि यह 4 spaces इंडेंट है:

````example
```
aaa
    ```
.
<pre><code>aaa
    ```
</code></pre>
````

Code fences (शुरुआती और समापन) में आंतरिक spaces नहीं हो सकते:

````example
``` ```
aaa
.
<p><code> </code>
aaa</p>
````

```example
~~~~~~
aaa
~~~ ~~
.
<pre><code>aaa
~~~ ~~
</code></pre>
```

Fenced code blocks पैराग्राफ को बाधित कर सकते हैं, और बिना किसी खाली लाइन के सीधे पैराग्राफ द्वारा अनुसरण किए जा सकते हैं:

````example
foo
```
bar
```
baz
.
<p>foo</p>
<pre><code>bar
</code></pre>
<p>baz</p>
````

अन्य ब्लॉक्स भी fenced code blocks के पहले और बाद में बिना किसी बीच की खाली लाइन के हो सकते हैं:

```example
foo
---
~~~
bar
~~~
# baz
.
<h2>foo</h2>
<pre><code>bar
</code></pre>
<h1>baz</h1>
```

शुरुआती code fence के बाद एक [info string] प्रदान की जा सकती है। यद्यपि यह spec info string के किसी विशेष उपचार को अनिवार्य नहीं करता है, पहले शब्द का उपयोग आमतौर पर कोड ब्लॉक की भाषा निर्दिष्ट करने के लिए किया जाता है। HTML आउटपुट में, भाषा को सामान्य रूप से `code` एलिमेंट में `language-` के बाद भाषा नाम युक्त एक class जोड़कर संकेत दिया जाता है।

````example
```ruby
def foo(x)
  return 3
end
```
.
<pre><code class="language-ruby">def foo(x)
  return 3
end
</code></pre>
````

```example
~~~~    ruby startline=3 $%@#$
def foo(x)
  return 3
end
~~~~~~~
.
<pre><code class="language-ruby">def foo(x)
  return 3
end
</code></pre>
```

`````example
````;
````
.
<pre><code class="language-;"></code></pre>
`````

backtick code blocks के लिए [Info strings] में backticks नहीं हो सकते:

````example
``` aa ```
foo
.
<p><code>aa</code>
foo</p>
````

tilde code blocks के लिए [Info strings] में backticks और tildes हो सकते हैं:

````example
~~~ aa ``` ~~~
foo
~~~
.
<pre><code class="language-aa">foo
</code></pre>
````

समापन code fences में [info strings] नहीं हो सकती:

````example
```
``` aaa
```
.
<pre><code>``` aaa
</code></pre>
````

## HTML ब्लॉक्स

एक [HTML block](@) लाइनों का एक समूह है जिसे raw HTML के रूप में माना जाता है (और HTML आउटपुट में escaped नहीं किया जाएगा)।

[HTML block] के सात प्रकार हैं, जिन्हें उनकी प्रारंभ और समाप्ति शर्तों द्वारा परिभाषित किया जा सकता है। ब्लॉक एक ऐसी लाइन से शुरू होता है जो [start condition](@) को पूरा करती है (तीन spaces तक वैकल्पिक इंडेंटेशन के बाद)। यह पहली बाद की लाइन पर समाप्त होता है जो मिलती हुई [end condition](@) को पूरा करती है, या दस्तावेज़ की अंतिम लाइन, या वर्तमान HTML block युक्त [container block](#container-blocks) की अंतिम लाइन, यदि कोई लाइन नहीं मिलती जो [end condition] को पूरा करे। यदि पहली लाइन [start condition] और [end condition] दोनों को पूरा करती है, तो ब्लॉक में केवल वह लाइन होगी।

1.  **प्रारंभ शर्त:** लाइन स्ट्रिंग `<script`, `<pre`, या `<style` (case-insensitive) से शुरू होती है, जिसके बाद whitespace, स्ट्रिंग `>`, या लाइन का अंत होता है।\
    **समाप्ति शर्त:** लाइन में एक end tag `</script>`, `</pre>`, या `</style>` है (case-insensitive; इसे start tag से मेल खाने की आवश्यकता नहीं है)।

2.  **प्रारंभ शर्त:** लाइन स्ट्रिंग `<!--` से शुरू होती है।\
    **समाप्ति शर्त:** लाइन में स्ट्रिंग `-->` है।

3.  **प्रारंभ शर्त:** लाइन स्ट्रिंग `<?` से शुरू होती है।\
    **समाप्ति शर्त:** लाइन में स्ट्रिंग `?>` है।

4.  **प्रारंभ शर्त:** लाइन स्ट्रिंग `<!` से शुरू होती है जिसके बाद एक uppercase ASCII अक्षर होता है।\
    **समाप्ति शर्त:** लाइन में वर्ण `>` है।

5.  **प्रारंभ शर्त:** लाइन स्ट्रिंग `<![CDATA[` से शुरू होती है।\
    **समाप्ति शर्त:** लाइन में स्ट्रिंग `]]>` है।

6.  **प्रारंभ शर्त:** लाइन स्ट्रिंग `<` या `</` से शुरू होती है जिसके बाद निम्नलिखित स्ट्रिंग्स में से एक (case-insensitive) `address`, `article`, `aside`, `base`, `basefont`, `blockquote`, `body`, `caption`, `center`, `col`, `colgroup`, `dd`, `details`, `dialog`, `dir`, `div`, `dl`, `dt`, `fieldset`, `figcaption`, `figure`, `footer`, `form`, `frame`, `frameset`, `h1`, `h2`, `h3`, `h4`, `h5`, `h6`, `head`, `header`, `hr`, `html`, `iframe`, `legend`, `li`, `link`, `main`, `menu`, `menuitem`, `nav`, `noframes`, `ol`, `optgroup`, `option`, `p`, `param`, `section`, `summary`, `table`, `tbody`, `td`, `tfoot`, `th`, `thead`, `title`, `tr`, `track`, `ul` होती है, जिसके बाद [whitespace], लाइन का अंत, स्ट्रिंग `>`, या स्ट्रिंग `/>` होती है।\
    **समाप्ति शर्त:** लाइन के बाद एक [blank line] होती है।

7.  **प्रारंभ शर्त:** लाइन एक पूर्ण [open tag] (किसी भी [tag name] के साथ जो `script`, `style`, या `pre` नहीं है) या एक पूर्ण [closing tag] से शुरू होती है, जिसके बाद केवल [whitespace] या लाइन का अंत होता है।\
    **समाप्ति शर्त:** लाइन के बाद एक [blank line] होती है।

HTML blocks तब तक जारी रहते हैं जब तक कि वे अपनी उपयुक्त [end condition] द्वारा बंद नहीं किए जाते, या दस्तावेज़ की अंतिम लाइन या अन्य [container block](#container-blocks)। इसका मतलब है कि **HTML block के भीतर** कोई भी HTML जिसे अन्यथा प्रारंभ शर्त के रूप में पहचाना जा सकता है, पार्सर द्वारा नजरअंदाज किया जाएगा और पार्सर की स्थिति बदले बिना as-is पास किया जाएगा।

उदाहरण के लिए, `<table>` द्वारा शुरू किए गए HTML block के भीतर `<pre>` पार्सर स्थिति को प्रभावित नहीं करेगा; चूंकि HTML block प्रारंभ शर्त 6 द्वारा शुरू किया गया था, यह किसी भी खाली लाइन पर समाप्त होगा। यह आश्चर्यजनक हो सकता है:

```example
<table><tr><td>
<pre>
**Hello**,

_world_.
</pre>
</td></tr></table>
.
<table><tr><td>
<pre>
**Hello**,
<p><em>world</em>.
</pre></p>
</td></tr></table>
```

इस मामले में, HTML block newline द्वारा समाप्त किया जाता है — `**Hello**` टेक्स्ट verbatim रहता है — और नियमित पार्सिंग फिर से शुरू होती है, एक पैराग्राफ, ज़ोर दिया गया `world` और इनलाइन और ब्लॉक HTML के बाद।

सभी प्रकार के [HTML blocks] प्रकार 7 को छोड़कर एक पैराग्राफ को बाधित कर सकते हैं। प्रकार 7 के ब्लॉक्स एक पैराग्राफ को बाधित नहीं कर सकते। (यह प्रतिबंध एक wrapped पैराग्राफ के अंदर लंबे टैग्स की अवांछित व्याख्या को HTML blocks शुरू करने के रूप में रोकने के लिए है।)

कुछ सरल उदाहरण निम्नलिखित हैं। यहां प्रकार 6 के कुछ बुनियादी HTML blocks हैं:

```example
<table>
  <tr>
    <td>
           hi
    </td>
  </tr>
</table>

okay.
.
<table>
  <tr>
    <td>
           hi
    </td>
  </tr>
</table>
<p>okay.</p>
```

```example
 <div>
  *hello*
         <foo><a>
.
 <div>
  *hello*
         <foo><a>
```

एक ब्लॉक समापन टैग के साथ भी शुरू हो सकता है:

```example
</div>
*foo*
.
</div>
*foo*
```

यहां हमारे पास उनके बीच Markdown पैराग्राफ के साथ दो HTML blocks हैं:

```example
<DIV CLASS="foo">

*Markdown*

</DIV>
.
<DIV CLASS="foo">
<p><em>Markdown</em></p>
</DIV>
```

पहली लाइन पर टैग आंशिक हो सकता है, जब तक कि यह वहां विभाजित है जहां whitespace होगा:

```example
<div id="foo"
  class="bar">
</div>
.
<div id="foo"
  class="bar">
</div>
```

```example
<div id="foo" class="bar
  baz">
</div>
.
<div id="foo" class="bar
  baz">
</div>
```

एक open tag को बंद करने की आवश्यकता नहीं है:

```example
<div>
*foo*

*bar*
.
<div>
*foo*
<p><em>bar</em></p>
```

एक आंशिक टैग को पूर्ण करने की भी आवश्यकता नहीं है (garbage in, garbage out):

```example
<div id="foo"
*hi*
.
<div id="foo"
*hi*
```

```example
<div class
foo
.
<div class
foo
```

प्रारंभिक टैग को मान्य टैग होने की भी आवश्यकता नहीं है, जब तक कि यह एक की तरह शुरू होता है:

```example
<div *???-&&&-<---
*foo*
.
<div *???-&&&-<---
*foo*
```

प्रकार 6 blocks में, प्रारंभिक टैग को स्वयं एक लाइन पर होने की आवश्यकता नहीं है:

```example
<div><a href="bar">*foo*</a></div>
.
<div><a href="bar">*foo*</a></div>
```

```example
<table><tr><td>
foo
</td></tr></table>
.
<table><tr><td>
foo
</td></tr></table>
```

अगली खाली लाइन या दस्तावेज़ के अंत तक सब कुछ HTML block में शामिल हो जाता है। इसलिए, निम्नलिखित उदाहरण में, जो Markdown कोड ब्लॉक की तरह दिखता है वह वास्तव में HTML block का हिस्सा है, जो खाली लाइन या दस्तावेज़ के अंत तक पहुंचने तक जारी रहता है:

````example
<div></div>
``` c
int x = 33;
```
.
<div></div>
``` c
int x = 33;
```
````

(6) में ब्लॉक-स्तरीय टैग्स की सूची में _नहीं_ है ऐसे टैग के साथ [HTML block] शुरू करने के लिए, आपको टैग को स्वयं पहली लाइन पर रखना होगा (और यह पूर्ण होना चाहिए):

```example
<a href="foo">
*bar*
</a>
.
<a href="foo">
*bar*
</a>
```

प्रकार 7 blocks में, [tag name] कुछ भी हो सकता है:

```example
<Warning>
*bar*
</Warning>
.
<Warning>
*bar*
</Warning>
```

```example
<i class="foo">
*bar*
</i>
.
<i class="foo">
*bar*
</i>
```

```example
</ins>
*bar*
.
</ins>
*bar*
```

ये नियम हमें उन टैग्स के साथ काम करने की अनुमति देने के लिए डिज़ाइन किए गए हैं जो ब्लॉक-स्तरीय या इनलाइन-स्तरीय टैग के रूप में कार्य कर सकते हैं। `<del>` टैग एक अच्छा उदाहरण है। हम तीन अलग-अलग तरीकों से `<del>` टैग्स के साथ सामग्री को घेर सकते हैं। इस मामले में, हमें एक raw HTML block मिलता है, क्योंकि `<del>` टैग स्वयं एक लाइन पर है:

```example
<del>
*foo*
</del>
.
<del>
*foo*
</del>
```

इस मामले में, हमें एक raw HTML block मिलता है जिसमें केवल `<del>` टैग शामिल है (क्योंकि यह निम्नलिखित खाली लाइन के साथ समाप्त होता है)। इसलिए सामग्री को CommonMark के रूप में व्याख्यायित किया जाता है:

```example
<del>

*foo*

</del>
.
<del>
<p><em>foo</em></p>
</del>
```

अंत में, इस मामले में, `<del>` टैग्स को CommonMark पैराग्राफ _के अंदर_ [raw HTML] के रूप में व्याख्यायित किया जाता है। (क्योंकि टैग स्वयं एक लाइन पर नहीं है, हमें [HTML block] के बजाय इनलाइन HTML मिलता है।)

```example
<del>*foo*</del>
.
<p><del><em>foo</em></del></p>
```

शाब्दिक सामग्री (`script`, `style`, `pre`) युक्त करने के लिए डिज़ाइन किए गए HTML टैग्स, comments, processing instructions, और declarations को कुछ अलग तरीके से माना जाता है। पहली खाली लाइन पर समाप्त होने के बजाय, ये ब्लॉक्स पहली लाइन पर समाप्त होते हैं जिसमें एक संबंधित end tag होता है। परिणामस्वरूप, इन ब्लॉक्स में खाली लाइनें हो सकती हैं:

pre टैग (प्रकार 1):

```example
<pre language="haskell"><code>
import Text.HTML.TagSoup

main :: IO ()
main = print $ parseTags tags
</code></pre>
okay
.
<pre language="haskell"><code>
import Text.HTML.TagSoup

main :: IO ()
main = print $ parseTags tags
</code></pre>
<p>okay</p>
```

script टैग (प्रकार 1):

```example
<script type="text/javascript">
// JavaScript उदाहरण

document.getElementById("demo").innerHTML = "Hello JavaScript!";
</script>
okay
.
<script type="text/javascript">
// JavaScript उदाहरण

document.getElementById("demo").innerHTML = "Hello JavaScript!";
</script>
<p>okay</p>
```

style टैग (प्रकार 1):

```example
<style
  type="text/css">
h1 {color:red;}

p {color:blue;}
</style>
okay
.
<style
  type="text/css">
h1 {color:red;}

p {color:blue;}
</style>
<p>okay</p>
```

यदि कोई मिलता हुआ end tag नहीं है, तो ब्लॉक दस्तावेज़ के अंत (या युक्त [block quote][block quotes] या [list item][list items]) पर समाप्त होगा:

```example
<style
  type="text/css">

foo
.
<style
  type="text/css">

foo
```

```example
> <div>
> foo

bar
.
<blockquote>
<div>
foo
</blockquote>
<p>bar</p>
```

```example
- <div>
- foo
.
<ul>
<li>
<div>
</li>
<li>foo</li>
</ul>
```

end tag start tag के समान लाइन पर हो सकता है:

```example
<style>p{color:red;}</style>
*foo*
.
<style>p{color:red;}</style>
<p><em>foo</em></p>
```

```example
<!-- foo -->*bar*
*baz*
.
<!-- foo -->*bar*
<p><em>baz</em></p>
```

ध्यान दें कि end tag के बाद अंतिम लाइन पर कुछ भी [HTML block] में शामिल होगा:

```example
<script>
foo
</script>1. *bar*
.
<script>
foo
</script>1. *bar*
```

comment (प्रकार 2):

```example
<!-- Foo

bar
   baz -->
okay
.
<!-- Foo

bar
   baz -->
<p>okay</p>
```

processing instruction (प्रकार 3):

```example
<?php

  echo '>';

?>
okay
.
<?php

  echo '>';

?>
<p>okay</p>
```

declaration (प्रकार 4):

```example
<!DOCTYPE html>
.
<!DOCTYPE html>
```

CDATA (प्रकार 5):

```example
<![CDATA[
function matchwo(a,b)
{
  if (a < b && a < 0) then {
    return 1;

  } else {

    return 0;
  }
}
]]>
okay
.
<![CDATA[
function matchwo(a,b)
{
  if (a < b && a < 0) then {
    return 1;

  } else {

    return 0;
  }
}
]]>
<p>okay</p>
```

शुरुआती टैग को 1-3 spaces इंडेंट किया जा सकता है, लेकिन 4 नहीं:

```example
  <!-- foo -->

    <!-- foo -->
.
  <!-- foo -->
<pre><code>&lt;!-- foo --&gt;
</code></pre>
```

```example
  <div>

    <div>
.
  <div>
<pre><code>&lt;div&gt;
</code></pre>
```

प्रकार 1--6 के HTML block एक पैराग्राफ को बाधित कर सकते हैं, और इससे पहले खाली लाइन की आवश्यकता नहीं है।

```example
Foo
<div>
bar
</div>
.
<p>Foo</p>
<div>
bar
</div>
```

हालांकि, एक बाद की खाली लाइन की आवश्यकता है, दस्तावेज़ के अंत को छोड़कर, और प्रकार 1--5 के blocks को छोड़कर, [above][HTML block]:

```example
<div>
bar
</div>
*foo*
.
<div>
bar
</div>
*foo*
```

प्रकार 7 के HTML blocks एक पैराग्राफ को बाधित नहीं कर सकते:

```example
Foo
<a href="bar">
baz
.
<p>Foo
<a href="bar">
baz</p>
```

यह नियम John Gruber के मूल Markdown सिंटैक्स विनिर्देश से अलग है, जो कहता है:

> केवल प्रतिबंध यह हैं कि ब्लॉक-स्तरीय HTML एलिमेंट्स —
> जैसे `<div>`, `<table>`, `<pre>`, `<p>`, आदि — आसपास की सामग्री से खाली लाइनों द्वारा अलग किए जाने चाहिए, और ब्लॉक के start और end टैग्स को tabs या spaces के साथ इंडेंट नहीं किया जाना चाहिए।

कुछ मायनों में Gruber का नियम यहां दिए गए नियम से अधिक प्रतिबंधात्मक है:

- इसके लिए आवश्यक है कि HTML block से पहले एक खाली लाइन हो।
- यह start tag को इंडेंट करने की अनुमति नहीं देता है।
- इसके लिए एक मिलता हुआ end tag आवश्यक है, जिसे इंडेंट करने की भी अनुमति नहीं है।

अधिकांश Markdown कार्यान्वयन (Gruber के अपने कुछ सहित) इन सभी प्रतिबंधों का सम्मान नहीं करते हैं।

हालांकि, एक मामले में Gruber का नियम यहां दिए गए नियम से अधिक उदार है, क्योंकि यह HTML block के अंदर खाली लाइनों को होने की अनुमति देता है। यहां उन्हें अस्वीकार करने के दो कारण हैं। पहला, यह संतुलित टैग्स को पार्स करने की आवश्यकता को हटा देता है, जो महंगा है और यदि कोई मिलता हुआ end tag नहीं मिलता है तो दस्तावेज़ के अंत से backtracking की आवश्यकता हो सकती है। दूसरा, यह HTML टैग्स के अंदर Markdown सामग्री शामिल करने का एक बहुत सरल और लचीला तरीका प्रदान करता है: बस खाली लाइनों का उपयोग करके HTML से Markdown को अलग करें:

तुलना करें:

```example
<div>

*Emphasized* text.

</div>
.
<div>
<p><em>Emphasized</em> text.</p>
</div>
```

```example
<div>
*Emphasized* text.
</div>
.
<div>
*Emphasized* text.
</div>
```

कुछ Markdown कार्यान्वयनों ने टैग्स के अंदर सामग्री को टेक्स्ट के रूप में व्याख्यायित करने के एक सम्मेलन को अपनाया है यदि open tag में एट्रिब्यूट `markdown=1` है। ऊपर दिया गया नियम समान अभिव्यंजक शक्ति प्राप्त करने का एक सरल और अधिक सुरुचिपूर्ण तरीका लगता है, जो पार्स करने के लिए भी बहुत सरल है।

मुख्य संभावित कमी यह है कि कोई अब 100% विश्वसनीयता के साथ Markdown दस्तावेज़ों में HTML blocks को पेस्ट नहीं कर सकता है। हालांकि, _अधिकांश मामलों में_ यह ठीक काम करेगा, क्योंकि HTML में खाली लाइनों के बाद आमतौर पर HTML block टैग्स आते हैं। उदाहरण के लिए:

```example
<table>

<tr>

<td>
Hi
</td>

</tr>

</table>
.
<table>
<tr>
<td>
Hi
</td>
</tr>
</table>
```

हालांकि, समस्याएं हैं, यदि आंतरिक टैग्स इंडेंट हैं _और_ spaces द्वारा अलग हैं, क्योंकि तब उन्हें एक इंडेंटेड कोड ब्लॉक के रूप में व्याख्यायित किया जाएगा:

```example
<table>

  <tr>

    <td>
      Hi
    </td>

  </tr>

</table>
.
<table>
  <tr>
<pre><code>&lt;td&gt;
  Hi
&lt;/td&gt;
</code></pre>
  </tr>
</table>
```

सौभाग्य से, खाली लाइनें आमतौर पर आवश्यक नहीं होती हैं और हटाई जा सकती हैं। अपवाद `<pre>` टैग्स के अंदर है, लेकिन जैसा कि [above][HTML blocks] में वर्णित है, `<pre>` से शुरू होने वाले raw HTML blocks खाली लाइनें शामिल _कर सकते हैं_।

## लिंक संदर्भ परिभाषाएं

एक [link reference definition](@) एक [link label] से बना है, तीन spaces तक इंडेंट, जिसके बाद एक colon (`:`), वैकल्पिक [whitespace] (एक [line ending] तक शामिल), एक [link destination], वैकल्पिक [whitespace] (एक [line ending] तक शामिल), और एक वैकल्पिक [link title] होता है, जो यदि मौजूद है तो [link destination] से [whitespace] द्वारा अलग किया जाना चाहिए। लाइन पर कोई और [non-whitespace characters] नहीं हो सकते।

एक [link reference definition] दस्तावेज़ के एक संरचनात्मक तत्व के अनुरूप नहीं है। इसके बजाय, यह एक लेबल परिभाषित करता है जिसका उपयोग दस्तावेज़ में कहीं और [reference links] और reference-style [images] में किया जा सकता है। [Link reference definitions] उनका उपयोग करने वाले लिंक्स से पहले या बाद में आ सकती हैं।

```example
[foo]: /url "title"

[foo]
.
<p><a href="/url" title="title">foo</a></p>
```

```example
   [foo]:
      /url
           'the title'

[foo]
.
<p><a href="/url" title="the title">foo</a></p>
```

```example
[Foo*bar\]]:my_(url) 'title (with parens)'

[Foo*bar\]]
.
<p><a href="my_(url)" title="title (with parens)">Foo*bar]</a></p>
```

```example
[Foo bar]:
<my url>
'title'

[Foo bar]
.
<p><a href="my%20url" title="title">Foo bar</a></p>
```

शीर्षक कई लाइनों में फैल सकता है:

```example
[foo]: /url '
title
line1
line2
'

[foo]
.
<p><a href="/url" title="
title
line1
line2
">foo</a></p>
```

हालांकि, इसमें एक [blank line] नहीं हो सकती:

```example
[foo]: /url 'title

with blank line'

[foo]
.
<p>[foo]: /url 'title</p>
<p>with blank line'</p>
<p>[foo]</p>
```

शीर्षक को छोड़ा जा सकता है:

```example
[foo]:
/url

[foo]
.
<p><a href="/url">foo</a></p>
```

लिंक destination को छोड़ा नहीं जा सकता:

```example
[foo]:

[foo]
.
<p>[foo]:</p>
<p>[foo]</p>
```

हालांकि, angle brackets का उपयोग करके एक खाली लिंक destination निर्दिष्ट किया जा सकता है:

```example
[foo]: <>

[foo]
.
<p><a href="">foo</a></p>
```

शीर्षक को लिंक destination से whitespace द्वारा अलग किया जाना चाहिए:

```example
[foo]: <bar>(baz)

[foo]
.
<p>[foo]: <bar>(baz)</p>
<p>[foo]</p>
```

शीर्षक और destination दोनों backslash escapes और शाब्दिक backslashes शामिल कर सकते हैं:

```example
[foo]: /url\bar\*baz "foo\"bar\baz"

[foo]
.
<p><a href="/url%5Cbar*baz" title="foo&quot;bar\baz">foo</a></p>
```

एक लिंक अपनी संबंधित परिभाषा से पहले आ सकता है:

```example
[foo]

[foo]: url
.
<p><a href="url">foo</a></p>
```

यदि कई मिलती-जुलती परिभाषाएं हैं, तो पहली को प्राथमिकता मिलती है:

```example
[foo]

[foo]: first
[foo]: second
.
<p><a href="first">foo</a></p>
```

जैसा कि [Links] अनुभाग में noted है, labels का मिलान case-insensitive है ([matches] देखें)।

```example
[FOO]: /url

[Foo]
.
<p><a href="/url">Foo</a></p>
```

```example
[ΑΓΩ]: /φου

[αγω]
.
<p><a href="/%CF%86%CE%BF%CF%85">αγω</a></p>
```

यहां कोई संबंधित लिंक के बिना एक लिंक संदर्भ परिभाषा है। यह दस्तावेज़ में कुछ भी योगदान नहीं करती है।

```example
[foo]: /url
.
```

यहां एक और है:

```example
[
foo
]: /url
bar
.
<p>bar</p>
```

यह लिंक संदर्भ परिभाषा नहीं है, क्योंकि शीर्षक के बाद [non-whitespace characters] हैं:

```example
[foo]: /url "title" ok
.
<p>[foo]: /url &quot;title&quot; ok</p>
```

यह एक लिंक संदर्भ परिभाषा है, लेकिन इसमें कोई शीर्षक नहीं है:

```example
[foo]: /url
"title" ok
.
<p>&quot;title&quot; ok</p>
```

यह लिंक संदर्भ परिभाषा नहीं है, क्योंकि यह चार spaces इंडेंट है:

```example
    [foo]: /url "title"

[foo]
.
<pre><code>[foo]: /url &quot;title&quot;
</code></pre>
<p>[foo]</p>
```

यह लिंक संदर्भ परिभाषा नहीं है, क्योंकि यह कोड ब्लॉक के अंदर होती है:

````example
```
[foo]: /url
```

[foo]
.
<pre><code>[foo]: /url
</code></pre>
<p>[foo]</p>
````

एक [link reference definition] एक पैराग्राफ को बाधित नहीं कर सकती।

```example
Foo
[bar]: /baz

[bar]
.
<p>Foo
[bar]: /baz</p>
<p>[bar]</p>
```

हालांकि, यह सीधे अन्य ब्लॉक एलिमेंट्स, जैसे हेडिंग्स और थीमैटिक ब्रेक्स, का अनुसरण कर सकती है, और इसके बाद खाली लाइन की आवश्यकता नहीं है।

```example
# [Foo]
[foo]: /url
> bar
.
<h1><a href="/url">Foo</a></h1>
<blockquote>
<p>bar</p>
</blockquote>
```

```example
[foo]: /url
bar
===
[foo]
.
<h1>bar</h1>
<p><a href="/url">foo</a></p>
```

```example
[foo]: /url
===
[foo]
.
<p>===
<a href="/url">foo</a></p>
```

कई [link reference definitions] एक के बाद एक बिना बीच की खाली लाइनों के हो सकती हैं।

```example
[foo]: /foo-url "foo"
[bar]: /bar-url
  "bar"
[baz]: /baz-url

[foo],
[bar],
[baz]
.
<p><a href="/foo-url" title="foo">foo</a>,
<a href="/bar-url" title="bar">bar</a>,
<a href="/baz-url">baz</a></p>
```

[Link reference definitions] ब्लॉक containers के अंदर हो सकती हैं, जैसे सूचियाँ और ब्लॉक quotations। वे संपूर्ण दस्तावेज़ को प्रभावित करती हैं, न कि केवल container जिसमें वे परिभाषित हैं:

```example
[foo]

> [foo]: /url
.
<p><a href="/url">foo</a></p>
<blockquote>
</blockquote>
```

क्या कुछ [link reference definition] है यह इस बात से स्वतंत्र है कि क्या यह जो लिंक संदर्भ परिभाषित करती है वह दस्तावेज़ में उपयोग किया जाता है। इस प्रकार, उदाहरण के लिए, निम्नलिखित दस्तावेज़ में केवल एक लिंक संदर्भ परिभाषा है, और कोई दृश्य सामग्री नहीं है:

```example
[foo]: /url
.
```

## पैराग्राफ्स

गैर-खाली लाइनों का एक अनुक्रम जिसे अन्य प्रकार के blocks के रूप में व्याख्यायित नहीं किया जा सकता है, एक [paragraph](@) बनाता है। पैराग्राफ की सामग्री पैराग्राफ की raw सामग्री को इनलाइन के रूप में पार्स करने का परिणाम है। पैराग्राफ की raw सामग्री लाइनों को जोड़कर और प्रारंभिक और अंतिम [whitespace] को हटाकर बनाई जाती है।

दो पैराग्राफ के साथ एक सरल उदाहरण:

```example
aaa

bbb
.
<p>aaa</p>
<p>bbb</p>
```

पैराग्राफ कई लाइनें शामिल कर सकते हैं, लेकिन कोई खाली लाइनें नहीं:

```example
aaa
bbb

ccc
ddd
.
<p>aaa
bbb</p>
<p>ccc
ddd</p>
```

पैराग्राफ के बीच कई खाली लाइनों का कोई प्रभाव नहीं है:

```example
aaa


bbb
.
<p>aaa</p>
<p>bbb</p>
```

अग्रणी spaces को छोड़ दिया जाता है:

```example
  aaa
 bbb
.
<p>aaa
bbb</p>
```

पहली के बाद की लाइनें किसी भी मात्रा में इंडेंट हो सकती हैं, क्योंकि इंडेंटेड कोड ब्लॉक्स पैराग्राफ को बाधित नहीं कर सकते।

```example
aaa
             bbb
                                       ccc
.
<p>aaa
bbb
ccc</p>
```

हालांकि, पहली लाइन को अधिकतम तीन spaces इंडेंट किया जा सकता है, या एक इंडेंटेड कोड ब्लॉक ट्रिगर हो जाएगा:

```example
   aaa
bbb
.
<p>aaa
bbb</p>
```

```example
    aaa
bbb
.
<pre><code>aaa
</code></pre>
<p>bbb</p>
```

अंतिम spaces को इनलाइन पार्सिंग से पहले हटा दिया जाता है, इसलिए दो या अधिक spaces के साथ समाप्त होने वाला पैराग्राफ [hard line break] के साथ समाप्त नहीं होगा:

```example
aaa
bbb
.
<p>aaa<br />
bbb</p>
```

## खाली लाइनें

ब्लॉक-स्तरीय एलिमेंट्स के बीच [Blank lines] को नजरअंदाज किया जाता है, उस भूमिका को छोड़कर जो वे यह निर्धारित करने में निभाते हैं कि [list] [tight] है या [loose]।

दस्तावेज़ की शुरुआत और अंत में खाली लाइनें भी नजरअंदाज की जाती हैं।

```example


aaa


# aaa


.
<p>aaa</p>
<h1>aaa</h1>
```

<div class="extension">

## टेबल्स (एक्सटेंशन)

GFM `table` एक्सटेंशन को सक्षम करता है, जहां एक अतिरिक्त लीफ ब्लॉक प्रकार उपलब्ध है।

एक [table](@) पंक्तियों और स्तंभों के साथ डेटा की एक व्यवस्था है, जिसमें एक single header पंक्ति, हेडर को डेटा से अलग करने वाली एक [delimiter row], और शून्य या अधिक डेटा पंक्तियां शामिल हैं।

प्रत्येक पंक्ति में मनमाने टेक्स्ट युक्त सेल्स होते हैं, जिसमें [inlines] को पार्स किया जाता है, pipes (`|`) द्वारा अलग किया जाता है। पठन की स्पष्टता के लिए एक अग्रणी और अनुगामी pipe भी अनुशंसित है, और यदि अन्यथा पार्सिंग अस्पष्टता है। pipes और सेल सामग्री के बीच spaces को ट्रिम किया जाता है। ब्लॉक-स्तरीय एलिमेंट्स को टेबल में नहीं डाला जा सकता है।

[delimiter row](@) उन सेल्स से बनी है जिनकी एकमात्र सामग्री hyphens (`-`) हैं, और वैकल्पिक रूप से, एक अग्रणी या अनुगामी colon (`:`), या दोनों, क्रमशः बाएं, दाएं, या केंद्र संरेखण को इंगित करने के लिए।

```example table
| foo | bar |
| --- | --- |
| baz | bim |
.
<table>
<thead>
<tr>
<th>foo</th>
<th>bar</th>
</tr>
</thead>
<tbody>
<tr>
<td>baz</td>
<td>bim</td>
</tr>
</tbody>
</table>
```

एक स्तंभ में सेल्स को लंबाई में मेल खाने की आवश्यकता नहीं है, हालांकि यदि वे मेल खाते हैं तो पढ़ना आसान है। इसी तरह, अग्रणी और अनुगामी pipes का उपयोग असंगत हो सकता है:

```example table
| abc | defghi |
:-: | -----------:
bar | baz
.
<table>
<thead>
<tr>
<th align="center">abc</th>
<th align="right">defghi</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">bar</td>
<td align="right">baz</td>
</tr>
</tbody>
</table>
```

इसे escape करके सेल की सामग्री में एक pipe शामिल करें, अन्य इनलाइन स्पैन के अंदर भी:

```example table
| f\|oo  |
| ------ |
| b `\|` az |
| b **\|** im |
.
<table>
<thead>
<tr>
<th>f|oo</th>
</tr>
</thead>
<tbody>
<tr>
<td>b <code>|</code> az</td>
</tr>
<tr>
<td>b <strong>|</strong> im</td>
</tr>
</tbody>
</table>
```

टेबल पहली खाली लाइन, या किसी अन्य ब्लॉक-स्तरीय संरचना की शुरुआत पर टूट जाती है:

```example table
| abc | def |
| --- | --- |
| bar | baz |
> bar
.
<table>
<thead>
<tr>
<th>abc</th>
<th>def</th>
</tr>
</thead>
<tbody>
<tr>
<td>bar</td>
<td>baz</td>
</tr>
</tbody>
</table>
<blockquote>
<p>bar</p>
</blockquote>
```

```example table
| abc | def |
| --- | --- |
| bar | baz |
bar

bar
.
<table>
<thead>
<tr>
<th>abc</th>
<th>def</th>
</tr>
</thead>
<tbody>
<tr>
<td>bar</td>
<td>baz</td>
</tr>
<tr>
<td>bar</td>
<td></td>
</tr>
</tbody>
</table>
<p>bar</p>
```

हेडर पंक्ति को सेल्स की संख्या में [delimiter row] से मेल खाना चाहिए। यदि नहीं, तो टेबल को पहचाना नहीं जाएगा:

```example table
| abc | def |
| --- |
| bar |
.
<p>| abc | def |
| --- |
| bar |</p>
```

टेबल की शेष पंक्तियों में सेल्स की संख्या भिन्न हो सकती है। यदि हेडर पंक्ति में सेल्स की संख्या से कम संख्या में सेल्स हैं, तो खाली सेल्स डाले जाते हैं। यदि अधिक हैं, तो अतिरिक्त को नजरअंदाज किया जाता है:

```example table
| abc | def |
| --- | --- |
| bar |
| bar | baz | boo |
.
<table>
<thead>
<tr>
<th>abc</th>
<th>def</th>
</tr>
</thead>
<tbody>
<tr>
<td>bar</td>
<td></td>
</tr>
<tr>
<td>bar</td>
<td>baz</td>
</tr>
</tbody>
</table>
```

यदि body में कोई पंक्तियां नहीं हैं, तो HTML आउटपुट में कोई `<tbody>` उत्पन्न नहीं होता:

```example table
| abc | def |
| --- | --- |
.
<table>
<thead>
<tr>
<th>abc</th>
<th>def</th>
</tr>
</thead>
</table>
```

</div>

# कंटेनर ब्लॉक्स

एक [container block](#container-blocks) एक ब्लॉक है जिसमें अन्य ब्लॉक्स इसकी सामग्री के रूप में होते हैं। दो बुनियादी प्रकार के कंटेनर ब्लॉक्स हैं: [block quotes] और [list items]। [Lists] [list items] के लिए मेटा-containers हैं।

हम कंटेनर ब्लॉक्स के लिए सिंटैक्स को पुनरावर्ती रूप से परिभाषित करते हैं। परिभाषा का सामान्य रूप है:

> यदि X ब्लॉक्स का एक अनुक्रम है, तो X को इस तरह से रूपांतरित करने का परिणाम प्रकार Y का एक container है जिसमें ये ब्लॉक्स इसकी सामग्री के रूप में हैं।

इसलिए, हम बताते हैं कि ब्लॉक कोट या सूची आइटम क्या गिना जाता है यह बताकर कि इन्हें उनकी सामग्री से कैसे _जेनरेट_ किया जा सकता है। यह सिंटैक्स को परिभाषित करने के लिए पर्याप्त होना चाहिए, हालांकि यह इन कंस्ट्रक्शन को _पार्स_ करने के लिए एक recipe नहीं देता है। (एक recipe नीचे [A parsing strategy](#appendix-a-parsing-strategy) शीर्षक वाले अनुभाग में प्रदान की गई है।)

## ब्लॉक कोट्स

एक [block quote marker](@) 0-3 spaces के प्रारंभिक इंडेंट से बना है, साथ ही (a) वर्ण `>` के साथ एक निम्नलिखित space, या (b) एक single वर्ण `>` जिसके बाद space नहीं है।

निम्नलिखित नियम [block quotes] को परिभाषित करते हैं:

1.  **मूल मामला।** यदि लाइनों की एक स्ट्रिंग _Ls_ ब्लॉक्स _Bs_ का एक अनुक्रम बनाती है, तो _Ls_ में प्रत्येक लाइन की शुरुआत में [block quote marker] को जोड़ने का परिणाम _Bs_ युक्त एक [block quote](#block-quotes) है।

2.  **आलस्य।** यदि लाइनों की एक स्ट्रिंग _Ls_ सामग्री _Bs_ के साथ एक [block quote](#block-quotes) बनाती है, तो एक या अधिक लाइनों से प्रारंभिक [block quote marker] को हटाने का परिणाम जिनमें [block quote marker] के बाद अगला [non-whitespace character] [paragraph continuation text] है, _Bs_ इसकी सामग्री के रूप में एक block quote है। [Paragraph continuation text](@) वह टेक्स्ट है जिसे पैराग्राफ की सामग्री के हिस्से के रूप में पार्स किया जाएगा, लेकिन पैराग्राफ की शुरुआत में नहीं होता है।

3.  **लगातारता।** एक दस्तावेज़ में लगातार दो [block quotes] नहीं हो सकते हैं जब तक कि उनके बीच एक [blank line] न हो।

कुछ और [block quote](#block-quotes) के रूप में नहीं गिना जाता है।

यहां एक सरल उदाहरण है:

```example
> # Foo
> bar
> baz
.
<blockquote>
<h1>Foo</h1>
<p>bar
baz</p>
</blockquote>
```

`>` वर्णों के बाद spaces को छोड़ा जा सकता है:

```example
># Foo
>bar
> baz
.
<blockquote>
<h1>Foo</h1>
<p>bar
baz</p>
</blockquote>
```

`>` वर्णों को 1-3 spaces इंडेंट किया जा सकता है:

```example
   > # Foo
   > bar
 > baz
.
<blockquote>
<h1>Foo</h1>
<p>bar
baz</p>
</blockquote>
```

चार spaces हमें एक कोड ब्लॉक देते हैं:

```example
    > # Foo
    > bar
    > baz
.
<pre><code>&gt; # Foo
&gt; bar
&gt; baz
</code></pre>
```

आलस्य खंड हमें [paragraph continuation text] से पहले `>` को छोड़ने की अनुमति देता है:

```example
> # Foo
> bar
baz
.
<blockquote>
<h1>Foo</h1>
<p>bar
baz</p>
</blockquote>
```

एक ब्लॉक कोट में कुछ आलसी और कुछ गैर-आलसी कंटिन्यूएशन लाइनें हो सकती हैं:

```example
> bar
baz
> foo
.
<blockquote>
<p>bar
baz
foo</p>
</blockquote>
```

आलस्य केवल उन लाइनों पर लागू होता है जो पैराग्राफ की कंटिन्यूएशन होती हैं यदि उन्हें [block quote markers] के साथ prepend किया गया होता। उदाहरण के लिए, दूसरी लाइन में `> ` को छोड़ा नहीं जा सकता

```markdown
> ## foo
```

अर्थ बदले बिना:

```example
> foo
---
.
<blockquote>
<p>foo</p>
</blockquote>
<hr />
```

इसी तरह, यदि हम दूसरी लाइन में `> ` को छोड़ देते हैं

```markdown
> - foo
> - bar
```

तो ब्लॉक कोट पहली लाइन के बाद समाप्त हो जाता है:

```example
> - foo
- bar
.
<blockquote>
<ul>
<li>foo</li>
</ul>
</blockquote>
<ul>
<li>bar</li>
</ul>
```

इसी कारण से, हम एक इंडेंटेड या fenced code block की बाद की लाइनों के सामने `> ` को छोड़ नहीं सकते:

```example
>     foo
    bar
.
<blockquote>
<pre><code>foo
</code></pre>
</blockquote>
<pre><code>bar
</code></pre>
```

````example
> ```
foo
```
.
<blockquote>
<pre><code></code></pre>
</blockquote>
<p>foo</p>
<pre><code></code></pre>
````

ध्यान दें कि निम्नलिखित मामले में, हमारे पास एक [lazy continuation line] है:

```example
> foo
    - bar
.
<blockquote>
<p>foo
- bar</p>
</blockquote>
```

क्यों देखने के लिए, ध्यान दें कि

```markdown
> foo - bar
```

में `- bar` सूची शुरू करने के लिए बहुत अधिक इंडेंट है, और इंडेंटेड कोड ब्लॉक नहीं हो सकता क्योंकि इंडेंटेड कोड ब्लॉक्स पैराग्राफ को बाधित नहीं कर सकते, इसलिए यह [paragraph continuation text] है।

एक ब्लॉक कोट खाली हो सकता है:

```example
>
.
<blockquote>
</blockquote>
```

```example
>
>
>
.
<blockquote>
</blockquote>
```

एक ब्लॉक कोट में प्रारंभिक या अंतिम खाली लाइनें हो सकती हैं:

```example
>
> foo
>
.
<blockquote>
<p>foo</p>
</blockquote>
```

एक खाली लाइन हमेशा ब्लॉक कोट्स को अलग करती है:

```example
> foo

> bar
.
<blockquote>
<p>foo</p>
</blockquote>
<blockquote>
<p>bar</p>
</blockquote>
```

(अधिकांश वर्तमान Markdown कार्यान्वयन, John Gruber के मूल `Markdown.pl` सहित, इस उदाहरण को दो पैराग्राफ के साथ एक single ब्लॉक कोट के रूप में पार्स करेंगे। लेकिन लेखक को यह तय करने देना बेहतर लगता है कि दो ब्लॉक कोट्स या एक चाहिए।)

लगातारता का मतलब है कि यदि हम इन ब्लॉक कोट्स को एक साथ रखते हैं, तो हमें एक single ब्लॉक कोट मिलता है:

```example
> foo
> bar
.
<blockquote>
<p>foo
bar</p>
</blockquote>
```

दो पैराग्राफ के साथ एक ब्लॉक कोट प्राप्त करने के लिए, उपयोग करें:

```example
> foo
>
> bar
.
<blockquote>
<p>foo</p>
<p>bar</p>
</blockquote>
```

ब्लॉक कोट्स पैराग्राफ को बाधित कर सकते हैं:

```example
foo
> bar
.
<p>foo</p>
<blockquote>
<p>bar</p>
</blockquote>
```

सामान्य रूप से, ब्लॉक कोट्स के पहले या बाद में खाली लाइनों की आवश्यकता नहीं है:

```example
> aaa
***
> bbb
.
<blockquote>
<p>aaa</p>
</blockquote>
<hr />
<blockquote>
<p>bbb</p>
</blockquote>
```

हालांकि, आलस्य के कारण, ब्लॉक कोट और बाद के पैराग्राफ के बीच एक खाली लाइन की आवश्यकता है:

```example
> bar
baz
.
<blockquote>
<p>bar
baz</p>
</blockquote>
```

```example
> bar

baz
.
<blockquote>
<p>bar</p>
</blockquote>
<p>baz</p>
```

```example
> bar
>
baz
.
<blockquote>
<p>bar</p>
</blockquote>
<p>baz</p>
```

आलस्य नियम का एक परिणाम यह है कि nested ब्लॉक कोट की कंटिन्यूएशन लाइन पर प्रारंभिक `>`s की कोई भी संख्या छोड़ी जा सकती है:

```example
> > > foo
bar
.
<blockquote>
<blockquote>
<blockquote>
<p>foo
bar</p>
</blockquote>
</blockquote>
</blockquote>
```

```example
>>> foo
> bar
>>baz
.
<blockquote>
<blockquote>
<blockquote>
<p>foo
bar
baz</p>
</blockquote>
</blockquote>
</blockquote>
```

ब्लॉक कोट में इंडेंटेड कोड ब्लॉक शामिल करते समय, याद रखें कि [block quote marker] में `>` और एक निम्नलिखित space दोनों शामिल हैं। इसलिए `>` के बाद _पांच spaces_ की आवश्यकता है:

```example
>     code

>    not code
.
<blockquote>
<pre><code>code
</code></pre>
</blockquote>
<blockquote>
<p>not code</p>
</blockquote>
```

## सूची आइटम्स

एक [list marker](@) एक [bullet list marker] या एक [ordered list marker] है।

एक [bullet list marker](@) एक `-`, `+`, या `*` वर्ण है।

एक [ordered list marker](@) 1--9 अरबी अंकों (`0-9`) का एक अनुक्रम है, जिसके बाद या तो एक `.` वर्ण या एक `)` वर्ण होता है। (लंबाई सीमा का कारण यह है कि 10 अंकों के साथ हम कुछ ब्राउज़रों में integer overflows देखना शुरू करते हैं।)

निम्नलिखित नियम [list items] को परिभाषित करते हैं:

1.  **मूल मामला।** यदि लाइनों का एक अनुक्रम _Ls_ ब्लॉक्स _Bs_ का एक अनुक्रम बनाता है जो [non-whitespace character] से शुरू होता है, और _M_ चौड़ाई _W_ का एक list marker है जिसके बाद 1 ≤ _N_ ≤ 4 spaces हैं, तो _Ls_ की पहली लाइन के लिए _M_ और निम्नलिखित spaces को prepend करने, और _Ls_ की बाद की लाइनों को _W + N_ spaces द्वारा इंडेंट करने का परिणाम _Bs_ को इसकी सामग्री के रूप में एक list item है। सूची आइटम का प्रकार (bullet या ordered) इसके list marker के प्रकार द्वारा निर्धारित किया जाता है। यदि सूची आइटम ordered है, तो इसे ordered list marker के आधार पर एक start number भी दिया जाता है।

    अपवाद:
    1. जब [list] में पहला list item एक पैराग्राफ को बाधित करता है---यानी, जब यह एक ऐसी लाइन पर शुरू होता है जो अन्यथा [paragraph continuation text] के रूप में गिनी जाएगी---तो (a) लाइनें _Ls_ खाली लाइन से शुरू नहीं होनी चाहिए, और (b) यदि सूची आइटम ordered है, तो start number 1 होना चाहिए।
    2. यदि कोई लाइन [thematic break][thematic breaks] है तो वह लाइन list item नहीं है।

उदाहरण के लिए, _Ls_ को लाइनें मानें

```example
A paragraph
with two lines.

    indented code

> A block quote.
.
<p>A paragraph
with two lines.</p>
<pre><code>indented code
</code></pre>
<blockquote>
<p>A block quote.</p>
</blockquote>
```

और _M_ को marker `1.`, और _N_ = 2 मानें। तो नियम #1 कहता है कि निम्नलिखित start number 1 के साथ एक ordered list item है, और _Ls_ के समान सामग्री:

```example
1.  A paragraph
    with two lines.

        indented code

    > A block quote.
.
<ol>
<li>
<p>A paragraph
with two lines.</p>
<pre><code>indented code
</code></pre>
<blockquote>
<p>A block quote.</p>
</blockquote>
</li>
</ol>
```

सबसे महत्वपूर्ण बात यह है कि list marker के बाद टेक्स्ट की स्थिति यह निर्धारित करती है कि सूची आइटम में बाद के ब्लॉक्स में कितने इंडेंटेशन की आवश्यकता है। यदि list marker दो spaces लेता है, और list marker और अगले [non-whitespace character] के बीच तीन spaces हैं, तो ब्लॉक्स को सूची आइटम के अंतर्गत आने के लिए पांच spaces इंडेंट होना चाहिए।

यहां कुछ उदाहरण हैं जो दिखाते हैं कि सामग्री को सूची आइटम के अंतर्गत रखने के लिए कितना इंडेंट होना चाहिए:

```example
- one

 two
.
<ul>
<li>one</li>
</ul>
<p>two</p>
```

```example
- one

  two
.
<ul>
<li>
<p>one</p>
<p>two</p>
</li>
</ul>
```

```example
 -    one

     two
.
<ul>
<li>one</li>
</ul>
<pre><code> two
</code></pre>
```

```example
 -    one

      two
.
<ul>
<li>
<p>one</p>
<p>two</p>
</li>
</ul>
```

इसे columns के संदर्भ में सोचना आकर्षक है: कंटिन्यूएशन ब्लॉक्स को कम से कम list marker के बाद पहले [non-whitespace character] के column तक इंडेंट होना चाहिए। हालांकि, यह बिल्कुल सही नहीं है। list marker के बाद spaces यह निर्धारित करते हैं कि कितना सापेक्ष इंडेंटेशन आवश्यक है। यह इंडेंटेशन किस column तक पहुंचता है यह इस बात पर निर्भर करेगा कि सूची आइटम अन्य कंस्ट्रक्शन में कैसे एम्बेडेड है, जैसा कि इस उदाहरण से दिखाया गया है:

```example
   > > 1.  one
>>
>>     two
.
<blockquote>
<blockquote>
<ol>
<li>
<p>one</p>
<p>two</p>
</li>
</ol>
</blockquote>
</blockquote>
```

यहां `two` list marker `1.` के समान column में होता है, लेकिन वास्तव में सूची आइटम में शामिल है, क्योंकि अंतिम युक्त blockquote marker के बाद पर्याप्त इंडेंटेशन है।

विपरीत भी संभव है। निम्नलिखित उदाहरण में, शब्द `two` सूची आइटम के प्रारंभिक टेक्स्ट `one` के दाईं ओर बहुत दूर होता है, लेकिन इसे सूची आइटम का हिस्सा नहीं माना जाता है, क्योंकि यह blockquote marker को पार करने के लिए पर्याप्त इंडेंट नहीं है:

```example
>>- one
>>
  >  > two
.
<blockquote>
<blockquote>
<ul>
<li>one</li>
</ul>
<p>two</p>
</blockquote>
</blockquote>
```

ध्यान दें कि list marker और किसी भी निम्नलिखित सामग्री के बीच कम से कम एक space की आवश्यकता है, इसलिए ये सूची आइटम्स नहीं हैं:

```example
-one

2.two
.
<p>-one</p>
<p>2.two</p>
```

एक सूची आइटम में ऐसे ब्लॉक्स हो सकते हैं जो एक से अधिक खाली लाइन द्वारा अलग होते हैं।

```example
- foo


  bar
.
<ul>
<li>
<p>foo</p>
<p>bar</p>
</li>
</ul>
```

एक सूची आइटम में किसी भी प्रकार का ब्लॉक हो सकता है:

````example
1.  foo

    ```
    bar
    ```

    baz

    > bam
.
<ol>
<li>
<p>foo</p>
<pre><code>bar
</code></pre>
<p>baz</p>
<blockquote>
<p>bam</p>
</blockquote>
</li>
</ol>
````

इंडेंटेड कोड ब्लॉक युक्त सूची आइटम कोड ब्लॉक के भीतर खाली लाइनों को verbatim संरक्षित करेगा।

```example
- Foo

      bar


      baz
.
<ul>
<li>
<p>Foo</p>
<pre><code>bar


baz
</code></pre>
</li>
</ul>
```

ध्यान दें कि ordered list start numbers नौ अंक या उससे कम होनी चाहिए:

```example
123456789. ok
.
<ol start="123456789">
<li>ok</li>
</ol>
```

```example
1234567890. not ok
.
<p>1234567890. not ok</p>
```

start number 0s से शुरू हो सकता है:

```example
0. ok
.
<ol start="0">
<li>ok</li>
</ol>
```

```example
003. ok
.
<ol start="3">
<li>ok</li>
</ol>
```

start number नकारात्मक नहीं हो सकता:

```example
-1. not ok
.
<p>-1. not ok</p>
```

2.  **इंडेंटेड कोड के साथ शुरू होने वाला आइटम।** यदि लाइनों का एक अनुक्रम _Ls_ ब्लॉक्स _Bs_ का एक अनुक्रम बनाता है जो इंडेंटेड कोड ब्लॉक से शुरू होता है, और _M_ चौड़ाई _W_ का एक list marker है जिसके बाद एक space है, तो _Ls_ की पहली लाइन के लिए _M_ और निम्नलिखित space को prepend करने, और _Ls_ की बाद की लाइनों को _W + 1_ spaces द्वारा इंडेंट करने का परिणाम _Bs_ को इसकी सामग्री के रूप में एक list item है। यदि लाइन खाली है, तो इसे इंडेंट करने की आवश्यकता नहीं है। सूची आइटम का प्रकार (bullet या ordered) इसके list marker के प्रकार द्वारा निर्धारित किया जाता है। यदि सूची आइटम ordered है, तो इसे ordered list marker के आधार पर एक start number भी दिया जाता है।

इंडेंटेड कोड ब्लॉक को उस क्षेत्र के किनारे से चार spaces परे इंडेंट करना होगा जहां टेक्स्ट सूची आइटम में शामिल होगा। निम्नलिखित मामले में वह 6 spaces है:

```example
- foo

      bar
.
<ul>
<li>
<p>foo</p>
<pre><code>bar
</code></pre>
</li>
</ul>
```

और इस मामले में यह 11 spaces है:

```example
  10.  foo

           bar
.
<ol start="10">
<li>
<p>foo</p>
<pre><code>bar
</code></pre>
</li>
</ol>
```

यदि सूची आइटम में _पहला_ ब्लॉक इंडेंटेड कोड ब्लॉक है, तो नियम #2 के अनुसार, सामग्री को list marker के बाद _एक_ space इंडेंट होना चाहिए:

```example
    indented code

paragraph

    more code
.
<pre><code>indented code
</code></pre>
<p>paragraph</p>
<pre><code>more code
</code></pre>
```

```example
1.     indented code

   paragraph

       more code
.
<ol>
<li>
<pre><code>indented code
</code></pre>
<p>paragraph</p>
<pre><code>more code
</code></pre>
</li>
</ol>
```

ध्यान दें कि एक अतिरिक्त space इंडेंट को कोड ब्लॉक के अंदर space के रूप में व्याख्यायित किया जाता है:

```example
1.      indented code

   paragraph

       more code
.
<ol>
<li>
<pre><code> indented code
</code></pre>
<p>paragraph</p>
<pre><code>more code
</code></pre>
</li>
</ol>
```

ध्यान दें कि नियम #1 और #2 केवल दो मामलों पर लागू होते हैं: (a) वे मामले जिनमें सूची आइटम में शामिल की जाने वाली लाइनें [non-whitespace character] से शुरू होती हैं, और (b) वे मामले जिनमें वे इंडेंटेड कोड ब्लॉक से शुरू होती हैं। निम्नलिखित जैसे मामले में, जहां पहला ब्लॉक तीन-space इंडेंट से शुरू होता है, नियम हमें पूरी चीज को इंडेंट करके और list marker को prepend करके सूची आइटम बनाने की अनुमति नहीं देते:

```example
   foo

bar
.
<p>foo</p>
<p>bar</p>
```

```example
-    foo

  bar
.
<ul>
<li>foo</li>
</ul>
<p>bar</p>
```

यह कोई महत्वपूर्ण प्रतिबंध नहीं है, क्योंकि जब ब्लॉक 1-3 spaces इंडेंट के साथ शुरू होता है, तो व्याख्या में बदलाव के बिना इंडेंटेशन को हमेशा हटाया जा सकता है, नियम #1 को लागू करने की अनुमति देता है। इसलिए, उपरोक्त मामले में:

```example
-  foo

   bar
.
<ul>
<li>
<p>foo</p>
<p>bar</p>
</li>
</ul>
```

3.  **खाली लाइन के साथ शुरू होने वाला आइटम।** यदि एक single [blank line] से शुरू होने वाली लाइनों का एक अनुक्रम _Ls_ ब्लॉक्स _Bs_ का एक (संभवतः खाली) अनुक्रम बनाता है, जो एक-दूसरे से एक से अधिक खाली लाइन द्वारा अलग नहीं हैं, और _M_ चौड़ाई _W_ का एक list marker है, तो _Ls_ की पहली लाइन के लिए _M_ को prepend करने, और _Ls_ की बाद की लाइनों को _W + 1_ spaces द्वारा इंडेंट करने का परिणाम _Bs_ को इसकी सामग्री के रूप में एक list item है। यदि लाइन खाली है, तो इसे इंडेंट करने की आवश्यकता नहीं है। सूची आइटम का प्रकार (bullet या ordered) इसके list marker के प्रकार द्वारा निर्धारित किया जाता है। यदि सूची आइटम ordered है, तो इसे ordered list marker के आधार पर एक start number भी दिया जाता है।

यहां कुछ सूची आइटम्स हैं जो खाली लाइन से शुरू होते हैं लेकिन खाली नहीं हैं:

````example
-
  foo
-
  ```
  bar
  ```
-
      baz
.
<ul>
<li>foo</li>
<li>
<pre><code>bar
</code></pre>
</li>
<li>
<pre><code>baz
</code></pre>
</li>
</ul>
````

जब सूची आइटम खाली लाइन से शुरू होता है, तो list marker के बाद spaces की संख्या आवश्यक इंडेंटेशन को नहीं बदलती:

```example
-
  foo
.
<ul>
<li>foo</li>
</ul>
```

एक सूची आइटम अधिकतम एक खाली लाइन से शुरू हो सकता है। निम्नलिखित उदाहरण में, `foo` सूची आइटम का हिस्सा नहीं है:

```example
-

  foo
.
<ul>
<li></li>
</ul>
<p>foo</p>
```

यहां एक खाली bullet list item है:

```example
- foo
-
- bar
.
<ul>
<li>foo</li>
<li></li>
<li>bar</li>
</ul>
```

यह मायने नहीं रखता कि [list marker] के बाद spaces हैं:

```example
- foo
-
- bar
.
<ul>
<li>foo</li>
<li></li>
<li>bar</li>
</ul>
```

यहां एक खाली ordered list item है:

```example
1. foo
2.
3. bar
.
<ol>
<li>foo</li>
<li></li>
<li>bar</li>
</ol>
```

एक सूची खाली सूची आइटम से शुरू या समाप्त हो सकती है:

```example
*
.
<ul>
<li></li>
</ul>
```

हालांकि, एक खाली सूची आइटम पैराग्राफ को बाधित नहीं कर सकता:

```example
foo
*

foo
1.
.
<p>foo
*</p>
<p>foo
1.</p>
```

4.  **इंडेंटेशन।** यदि लाइनों का एक अनुक्रम _Ls_ नियम #1, #2, या #3 के अनुसार एक सूची आइटम बनाता है, तो _Ls_ की प्रत्येक लाइन को 1-3 spaces (प्रत्येक लाइन के लिए समान) द्वारा इंडेंट करने का परिणाम भी समान सामग्री और एट्रिब्यूट्स के साथ एक सूची आइटम बनाता है। यदि लाइन खाली है, तो इसे इंडेंट करने की आवश्यकता नहीं है।

एक space इंडेंट:

```example
 1.  A paragraph
     with two lines.

         indented code

     > A block quote.
.
<ol>
<li>
<p>A paragraph
with two lines.</p>
<pre><code>indented code
</code></pre>
<blockquote>
<p>A block quote.</p>
</blockquote>
</li>
</ol>
```

दो spaces इंडेंट:

```example
  1.  A paragraph
      with two lines.

          indented code

      > A block quote.
.
<ol>
<li>
<p>A paragraph
with two lines.</p>
<pre><code>indented code
</code></pre>
<blockquote>
<p>A block quote.</p>
</blockquote>
</li>
</ol>
```

तीन spaces इंडेंट:

```example
   1.  A paragraph
       with two lines.

           indented code

       > A block quote.
.
<ol>
<li>
<p>A paragraph
with two lines.</p>
<pre><code>indented code
</code></pre>
<blockquote>
<p>A block quote.</p>
</blockquote>
</li>
</ol>
```

चार spaces इंडेंट एक कोड ब्लॉक देता है:

```example
    1.  A paragraph
        with two lines.

            indented code

        > A block quote.
.
<pre><code>1.  A paragraph
    with two lines.

        indented code

    &gt; A block quote.
</code></pre>
```

5.  **आलस्य।** यदि लाइनों की एक स्ट्रिंग _Ls_ सामग्री _Bs_ के साथ एक [list item](#list-items) बनाती है, तो एक या अधिक लाइनों से कुछ या सभी इंडेंटेशन को हटाने का परिणाम जिनमें इंडेंटेशन के बाद अगला [non-whitespace character] [paragraph continuation text] है, समान सामग्री और एट्रिब्यूट्स के साथ एक list item है। unindented लाइनों को [lazy continuation line](@)s कहा जाता है।

यहां [lazy continuation lines] के साथ एक उदाहरण है:

```example
  1.  A paragraph
with two lines.

          indented code

      > A block quote.
.
<ol>
<li>
<p>A paragraph
with two lines.</p>
<pre><code>indented code
</code></pre>
<blockquote>
<p>A block quote.</p>
</blockquote>
</li>
</ol>
```

इंडेंटेशन को आंशिक रूप से हटाया जा सकता है:

```example
  1.  A paragraph
    with two lines.
.
<ol>
<li>A paragraph
with two lines.</li>
</ol>
```

ये उदाहरण दिखाते हैं कि nested संरचनाओं में आलस्य कैसे काम कर सकता है:

```example
> 1. > Blockquote
continued here.
.
<blockquote>
<ol>
<li>
<blockquote>
<p>Blockquote
continued here.</p>
</blockquote>
</li>
</ol>
</blockquote>
```

```example
> 1. > Blockquote
> continued here.
.
<blockquote>
<ol>
<li>
<blockquote>
<p>Blockquote
continued here.</p>
</blockquote>
</li>
</ol>
</blockquote>
```

6.  **बस इतना ही।** वह कुछ भी जो नियम #1--5 द्वारा सूची आइटम के रूप में नहीं गिना जाता है, [list item](#list-items) के रूप में गिना जाता है।

सबलिस्ट के लिए नियम सामान्य नियमों [above][List items] से आते हैं। एक sublist को उतने ही spaces इंडेंट होना चाहिए जितना एक पैराग्राफ को सूची आइटम में शामिल होने के लिए आवश्यक होगा।

इसलिए, इस मामले में हमें दो spaces इंडेंट की आवश्यकता है:

```example
- foo
  - bar
    - baz
      - boo
.
<ul>
<li>foo
<ul>
<li>bar
<ul>
<li>baz
<ul>
<li>boo</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
```

एक पर्याप्त नहीं है:

```example
- foo
 - bar
  - baz
   - boo
.
<ul>
<li>foo</li>
<li>bar</li>
<li>baz</li>
<li>boo</li>
</ul>
```

यहां हमें चार की आवश्यकता है, क्योंकि list marker चौड़ा है:

```example
10) foo
    - bar
.
<ol start="10">
<li>foo
<ul>
<li>bar</li>
</ul>
</li>
</ol>
```

तीन पर्याप्त नहीं हैं:

```example
10) foo
   - bar
.
<ol start="10">
<li>foo</li>
</ol>
<ul>
<li>bar</li>
</ul>
```

एक सूची आइटम में पहला ब्लॉक एक सूची हो सकती है:

```example
- - foo
.
<ul>
<li>
<ul>
<li>foo</li>
</ul>
</li>
</ul>
```

```example
1. - 2. foo
.
<ol>
<li>
<ul>
<li>
<ol start="2">
<li>foo</li>
</ol>
</li>
</ul>
</li>
</ol>
```

एक सूची आइटम में हेडिंग हो सकती है:

```example
- # Foo
- Bar
  ---
  baz
.
<ul>
<li>
<h1>Foo</h1>
</li>
<li>
<h2>Bar</h2>
baz</li>
</ul>
```

### प्रेरणा

John Gruber का Markdown spec सूची आइटम्स के बारे में निम्नलिखित कहता है:

1. "List markers आमतौर पर बाएं मार्जिन से शुरू होते हैं, लेकिन तीन spaces तक इंडेंट हो सकते हैं। List markers के बाद एक या अधिक spaces या tab होना चाहिए।"

2. "सूचियों को अच्छा दिखाने के लिए, आप hanging indents के साथ आइटम्स को wrap कर सकते हैं.... लेकिन यदि आप नहीं चाहते हैं, तो आपको ऐसा करने की आवश्यकता नहीं है।"

3. "सूची आइटम्स में कई पैराग्राफ हो सकते हैं। सूची आइटम में प्रत्येक बाद के पैराग्राफ को या तो 4 spaces या एक tab द्वारा इंडेंट होना चाहिए।"

4. "यह अच्छा लगता है यदि आप बाद के पैराग्राफ की प्रत्येक लाइन को इंडेंट करते हैं, लेकिन यहां फिर से, Markdown आपको आलसी होने की अनुमति देगा।"

5. "सूची आइटम के भीतर blockquote डालने के लिए, blockquote के `>` delimiters को इंडेंट करने की आवश्यकता है।"

6. "सूची आइटम के भीतर कोड ब्लॉक डालने के लिए, कोड ब्लॉक को दो बार इंडेंट करने की आवश्यकता है — 8 spaces या दो tabs।"

ये नियम निर्दिष्ट करते हैं कि सूची आइटम के अंतर्गत पैराग्राफ को चार spaces इंडेंट होना चाहिए (संभवतः, बाएं मार्जिन से, list marker की शुरुआत के बजाय, लेकिन यह नहीं कहा गया है), और सूची आइटम के अंतर्गत कोड को सामान्य चार के बजाय आठ spaces इंडेंट होना चाहिए। वे यह भी कहते हैं कि ब्लॉक कोट को इंडेंट होना चाहिए, लेकिन कितना नहीं; हालांकि, दिया गया उदाहरण चार spaces इंडेंटेशन है। यद्यपि अन्य प्रकार की ब्लॉक-स्तरीय सामग्री के बारे में कुछ नहीं कहा गया है, यह निश्चित रूप से यह अनुमान लगाना उचित है कि सूची आइटम के अंतर्गत _सभी_ ब्लॉक एलिमेंट्स, अन्य सूचियों सहित, को चार spaces इंडेंट होना चाहिए। इस सिद्धांत को _चार-space नियम_ कहा गया है।

चार-space नियम स्पष्ट और सिद्धांतवादी है, और यदि संदर्भ कार्यान्वयन `Markdown.pl` ने इसका पालन किया होता, तो यह शायद मानक बन गया होता। हालांकि, `Markdown.pl` ने पैराग्राफ और सबलिस्ट को केवल दो spaces इंडेंटेशन के साथ शुरू करने की अनुमति दी, कम से कम बाहरी स्तर पर। बदतर, इसका व्यवहार असंगत था: बाहरी स्तर की सूची की सबलिस्ट को दो spaces इंडेंटेशन की आवश्यकता थी, लेकिन इस सबलिस्ट की सबलिस्ट को तीन spaces की आवश्यकता थी। तो यह आश्चर्यजनक नहीं है कि Markdown के विभिन्न कार्यान्वयनों ने यह निर्धारित करने के लिए बहुत अलग नियम विकसित किए हैं कि सूची आइटम के अंतर्गत क्या आता है। (उदाहरण के लिए, Pandoc और python-Markdown, Gruber के सिंटैक्स विवरण और चार-space नियम के साथ रहे, जबकि discount, redcarpet, marked, PHP Markdown, और अन्य ने `Markdown.pl` के व्यवहार का अधिक निकटता से पालन किया।)

दुर्भाग्य से, कार्यान्वयनों के बीच विचलन को देखते हुए, सूची आइटम्स के लिए ऐसा spec देने का कोई तरीका नहीं है जो किसी भी मौजूदा दस्तावेज़ को तोड़ने की गारंटी नहीं देगा। हालांकि, यहां दिया गया spec चार-space नियम या अधिक क्षमाशील `Markdown.pl` व्यवहार के साथ फ़ॉर्मेट की गई सूचियों को सही ढंग से संभालना चाहिए, बशर्ते वे ऐसे तरीके से लेआउट हों जो मनुष्य के लिए पढ़ने के लिए स्वाभाविक है।

यहां रणनीति यह है कि list marker की चौड़ाई और इंडेंटेशन को यह निर्धारित करने दें कि ब्लॉक्स को सूची आइटम के अंतर्गत आने के लिए कितना इंडेंटेशन आवश्यक है, मार्जिन से एक निश्चित और मनमाना संख्या रखने के बजाय। लेखक सूची आइटम के body को एक इकाई के रूप में सोच सकता है जो list marker (और list marker पर किसी भी इंडेंटेशन) को फ़िट करने के लिए दाईं ओर पर्याप्त इंडेंट हो जाती है। (आलस्य नियम, #5, फिर कंटिन्यूएशन लाइनों को unindented होने की अनुमति देता है यदि आवश्यक हो।)

हम दावा करते हैं कि यह नियम मार्जिन से इंडेंटेशन के एक निश्चित स्तर की आवश्यकता वाले किसी भी नियम से बेहतर है। चार-space नियम स्पष्ट है लेकिन अस्वाभाविक। यह काफी अस्वाभाविक है कि

```markdown
- foo

  bar
  - baz
```

को एक हस्तक्षेप करने वाले पैराग्राफ के साथ दो सूचियों के रूप में पार्स किया जाना चाहिए,

```html
<ul>
  <li>foo</li>
</ul>
<p>bar</p>
<ul>
  <li>baz</li>
</ul>
```

जैसा कि चार-space नियम की मांग है, एक single सूची के बजाय,

```html
<ul>
  <li>
    <p>foo</p>
    <p>bar</p>
    <ul>
      <li>baz</li>
    </ul>
  </li>
</ul>
```

चार spaces का चुनाव मनमाना है। इसे सीखा जा सकता है, लेकिन इसका अनुमान लगाना संभव नहीं है, और यह नियमित रूप से शुरुआती लोगों को trip up करता है।

क्या दो-space नियम अपनाने में मदद मिलेगी? समस्या यह है कि ऐसा नियम, प्रारंभिक list marker के 1--3 spaces इंडेंटेशन की अनुमति देने वाले नियम के साथ, ऐसे टेक्स्ट को सूची आइटम में शामिल होने की अनुमति देता है जो मूल list marker से _कम_ इंडेंट है। उदाहरण के लिए, `Markdown.pl` पार्स करता है

```markdown
- one

two
```

को एक single list item के रूप में, `two` एक कंटिन्यूएशन पैराग्राफ के साथ:

```html
<ul>
  <li>
    <p>one</p>
    <p>two</p>
  </li>
</ul>
```

और इसी तरह

```markdown
> - one
>
> two
```

को

```html
<blockquote>
  <ul>
    <li>
      <p>one</p>
      <p>two</p>
    </li>
  </ul>
</blockquote>
```

के रूप में

यह अत्यधिक अस्वाभाविक है।

मार्जिन से निश्चित इंडेंट की आवश्यकता के बजाय, हम list marker से निश्चित इंडेंट (कहें, दो spaces, या यहां तक कि एक space) की आवश्यकता कर सकते हैं (जो स्वयं इंडेंट हो सकता है)। यह प्रस्ताव चर्चा की गई अंतिम विसंगति को हटा देगा। ऊपर प्रस्तुत spec के विपरीत, यह निम्नलिखित को subparagraph के साथ सूची आइटम के रूप में गिनेगा, भले ही पैराग्राफ `bar` पहले पैराग्राफ `foo` जितना इंडेंट नहीं है:

```markdown
10. foo

bar
```

तर्कसंगत रूप से यह टेक्स्ट subparagraph के रूप में `bar` के साथ सूची आइटम की तरह पढ़ा जाता है, जो प्रस्ताव के पक्ष में गिन सकता है। हालांकि, इस प्रस्ताव पर इंडेंटेड कोड को list marker के बाद छह spaces इंडेंट करना होगा। और यह बहुत सारे मौजूदा Markdown को तोड़ देगा, जिसमें पैटर्न है:

```markdown
1.  foo

        indented code
```

जहां कोड आठ spaces इंडेंट है। इसके विपरीत, ऊपर दिया गया spec इस टेक्स्ट को अपेक्षित रूप से पार्स करेगा, क्योंकि कोड ब्लॉक का इंडेंटेशन `foo` की शुरुआत से मापा जाता है।

एक मामला जिसे विशेष उपचार की आवश्यकता है वह एक सूची आइटम है जो इंडेंटेड कोड से _शुरू_ होता है। उस मामले में कितना इंडेंटेशन आवश्यक है, क्योंकि हमारे पास मापने के लिए "पहला पैराग्राफ" नहीं है? नियम #2 बस यह निर्धारित करता है कि ऐसे मामलों में, हम list marker से एक space इंडेंटेशन की आवश्यकता करते हैं (और फिर इंडेंटेड कोड के लिए सामान्य चार spaces)। यह उन मामलों में चार-space नियम से मेल खाएगा जहां list marker साथ ही इसका प्रारंभिक इंडेंटेशन चार spaces लेता है (एक सामान्य मामला), लेकिन अन्य मामलों में विचलित होगा।

<div class="extension">

## टास्क लिस्ट आइटम्स (एक्सटेंशन)

GFM `tasklist` एक्सटेंशन को सक्षम करता है, जहां [list items] पर एक अतिरिक्त प्रोसेसिंग चरण किया जाता है।

एक [task list item](@) एक [list item][list items] है जहां इसमें पहला ब्लॉक एक पैराग्राफ है जो [task list item marker] से शुरू होता है और किसी अन्य सामग्री से पहले कम से कम एक whitespace वर्ण होता है।

एक [task list item marker](@) वैकल्पिक संख्या में spaces, एक बाएं bracket (`[`), या तो एक whitespace वर्ण या अक्षर `x` छोटे या बड़े अक्षर में, और फिर एक दाएं bracket (`]`) से बना है।

रेंडर होने पर, [task list item marker] को एक semantic checkbox एलिमेंट से बदल दिया जाता है; HTML आउटपुट में, यह एक `<input type="checkbox">` एलिमेंट होगा।

यदि brackets के बीच का वर्ण whitespace वर्ण है, तो checkbox unchecked है। अन्यथा, checkbox checked है।

यह spec परिभाषित नहीं करता है कि checkbox एलिमेंट्स के साथ कैसे इंटरैक्ट किया जाता है: व्यवहार में, कार्यान्वयनकर्ता checkboxes को disabled या inmutable एलिमेंट्स के रूप में रेंडर करने के लिए स्वतंत्र हैं, या वे अंतिम रेंडर किए गए दस्तावेज़ में dynamic interactions (यानी checking, unchecking) को गतिशील रूप से संभाल सकते हैं।

```example disabled
- [ ] foo
- [x] bar
.
<ul>
<li><input disabled="" type="checkbox"> foo</li>
<li><input checked="" disabled="" type="checkbox"> bar</li>
</ul>
```

टास्क लिस्ट्स को मनमाने रूप से nested किया जा सकता है:

```example disabled
- [x] foo
  - [ ] bar
  - [x] baz
- [ ] bim
.
<ul>
<li><input checked="" disabled="" type="checkbox"> foo
<ul>
<li><input disabled="" type="checkbox"> bar</li>
<li><input checked="" disabled="" type="checkbox"> baz</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> bim</li>
</ul>
```

</div>

## सूचियाँ

एक [list](@) एक या अधिक सूची आइटम्स का एक अनुक्रम है [of the same type]। सूची आइटम्स किसी भी संख्या में खाली लाइनों द्वारा अलग हो सकते हैं।

दो सूची आइटम्स [of the same type](@) हैं यदि वे समान प्रकार के [list marker] से शुरू होते हैं। दो list markers समान प्रकार के हैं यदि (a) वे समान वर्ण (`-`, `+`, या `*`) का उपयोग करके bullet list markers हैं या (b) वे समान delimiter (या तो `.` या `)`) के साथ ordered list numbers हैं।

एक सूची एक [ordered list](@) है यदि इसके घटक सूची आइटम्स [ordered list markers] से शुरू होते हैं, और एक [bullet list](@) यदि इसके घटक सूची आइटम्स [bullet list markers] से शुरू होते हैं।

एक [ordered list] का [start number](@) इसके प्रारंभिक सूची आइटम के list number द्वारा निर्धारित किया जाता है। बाद के सूची आइटम्स के numbers को नजरअंदाज किया जाता है।

एक सूची [loose](@) है यदि इसके किसी भी घटक सूची आइटम्स को खाली लाइनों द्वारा अलग किया जाता है, या यदि इसके किसी भी घटक सूची आइटम्स में सीधे दो ब्लॉक-स्तरीय एलिमेंट्स हैं जिनके बीच खाली लाइन है। अन्यथा सूची [tight](@) है। (HTML आउटपुट में अंतर यह है कि loose list में पैराग्राफ `<p>` टैग्स में wrapped हैं, जबकि tight list में पैराग्राफ नहीं हैं।)

bullet या ordered list delimiter को बदलना एक नई सूची शुरू करता है:

```example
- foo
- bar
+ baz
.
<ul>
<li>foo</li>
<li>bar</li>
</ul>
<ul>
<li>baz</li>
</ul>
```

```example
1. foo
2. bar
3) baz
.
<ol>
<li>foo</li>
<li>bar</li>
</ol>
<ol start="3">
<li>baz</li>
</ol>
```

CommonMark में, एक सूची पैराग्राफ को बाधित कर सकती है। यानी, पैराग्राफ को निम्नलिखित सूची से अलग करने के लिए खाली लाइन की आवश्यकता नहीं है:

```example
Foo
- bar
- baz
.
<p>Foo</p>
<ul>
<li>bar</li>
<li>baz</li>
</ul>
```

`Markdown.pl` इसकी अनुमति नहीं देता, hard-wrapped लाइन में संख्या के माध्यम से सूची ट्रिगर करने के डर से:

```markdown
The number of windows in my house is 14. The number of doors is 6.
```

अजीब बात है कि `Markdown.pl` _करता_ है blockquote को पैराग्राफ को बाधित करने की अनुमति देता है, भले ही समान विचार लागू हो सकते हैं।

CommonMark में, हम सूचियों को पैराग्राफ को बाधित करने की अनुमति देते हैं, दो कारणों से। पहला, यह स्वाभाविक है और लोगों के लिए असामान्य नहीं है कि वे खाली लाइनों के बिना सूचियां शुरू करें:

```markdown
I need to buy

- new shoes
- a coat
- a plane ticket
```

दूसरा, हम आकर्षित हैं

> [एकरूपता के सिद्धांत](@):
> यदि टेक्स्ट के एक chunk का एक निश्चित अर्थ है, तो जब इसे container block (जैसे सूची आइटम या blockquote) में डाला जाता है तो यह समान अर्थ बनाए रखेगा।

(वास्तव में, [list items] और [block quotes] के लिए spec इस सिद्धांत को मानता है।) यह सिद्धांत implies करता है कि यदि

```markdown
- I need to buy
  - new shoes
  - a coat
  - a plane ticket
```

एक सूची आइटम है जिसमें पैराग्राफ है जिसके बाद nested sublist है, जैसा कि सभी Markdown कार्यान्वयन सहमत हैं कि यह है (हालांकि पैराग्राफ को `<p>` टैग्स के बिना रेंडर किया जा सकता है, क्योंकि सूची "tight" है), तो

```markdown
I need to buy

- new shoes
- a coat
- a plane ticket
```

स्वयं एक पैराग्राफ के बाद nested sublist होनी चाहिए।

चूंकि यह अच्छी तरह से स्थापित Markdown अभ्यास है कि सूचियों को सूची आइटम्स के अंदर पैराग्राफ को बाधित करने की अनुमति दी जाए, [एकरूपता के सिद्धांत] हमसे यह भी सूची आइटम्स के बाहर अनुमति देने की आवश्यकता करता है। ([reStructuredText](http://docutils.sourceforge.net/rst.html) एक अलग दृष्टिकोण अपनाता है, अन्य सूची आइटम्स के अंदर भी सूचियों से पहले खाली लाइनों की आवश्यकता है।)

hard-wrapped अंकों वाले पैराग्राफ में अवांछित सूचियों की समस्या को हल करने के लिए, हम केवल `1` से शुरू होने वाली सूचियों को पैराग्राफ को बाधित करने की अनुमति देते हैं। इस प्रकार,

```example
The number of windows in my house is
14.  The number of doors is 6.
.
<p>The number of windows in my house is
14.  The number of doors is 6.</p>
```

हम अभी भी ऐसे मामलों में अनपेक्षित परिणाम प्राप्त कर सकते हैं

```example
The number of windows in my house is
1.  The number of doors is 6.
.
<p>The number of windows in my house is</p>
<ol>
<li>The number of doors is 6.</li>
</ol>
```

लेकिन यह नियम अधिकांश spurious list captures को रोकना चाहिए।

आइटम्स के बीच किसी भी संख्या में खाली लाइनें हो सकती हैं:

```example
- foo

- bar


- baz
.
<ul>
<li>
<p>foo</p>
</li>
<li>
<p>bar</p>
</li>
<li>
<p>baz</p>
</li>
</ul>
```

```example
- foo
  - bar
    - baz


      bim
.
<ul>
<li>foo
<ul>
<li>bar
<ul>
<li>
<p>baz</p>
<p>bim</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
```

समान प्रकार की लगातार सूचियों को अलग करने के लिए, या सूची को इंडेंटेड कोड ब्लॉक से अलग करने के लिए जो अन्यथा अंतिम सूची आइटम के subparagraph के रूप में पार्स होगा, आप एक खाली HTML comment डाल सकते हैं:

```example
- foo
- bar

<!-- -->

- baz
- bim
.
<ul>
<li>foo</li>
<li>bar</li>
</ul>
<!-- -->
<ul>
<li>baz</li>
<li>bim</li>
</ul>
```

```example
-   foo

    notcode

-   foo

<!-- -->

    code
.
<ul>
<li>
<p>foo</p>
<p>notcode</p>
</li>
<li>
<p>foo</p>
</li>
</ul>
<!-- -->
<pre><code>code
</code></pre>
```

सूची आइटम्स को समान स्तर पर इंडेंट होने की आवश्यकता नहीं है। निम्नलिखित सूची आइटम्स को समान सूची स्तर पर आइटम्स के रूप में माना जाएगा, क्योंकि कोई भी पिछले सूची आइटम से संबंधित होने के लिए पर्याप्त इंडेंट नहीं है:

```example
- a
 - b
  - c
   - d
  - e
 - f
- g
.
<ul>
<li>a</li>
<li>b</li>
<li>c</li>
<li>d</li>
<li>e</li>
<li>f</li>
<li>g</li>
</ul>
```

```example
1. a

  2. b

   3. c
.
<ol>
<li>
<p>a</p>
</li>
<li>
<p>b</p>
</li>
<li>
<p>c</p>
</li>
</ol>
```

हालांकि, ध्यान दें कि सूची आइटम्स को तीन spaces से अधिक इंडेंट नहीं किया जा सकता है। यहां `- e` को पैराग्राफ कंटिन्यूएशन लाइन के रूप में माना जाता है, क्योंकि यह तीन spaces से अधिक इंडेंट है:

```example
- a
 - b
  - c
   - d
    - e
.
<ul>
<li>a</li>
<li>b</li>
<li>c</li>
<li>d
- e</li>
</ul>
```

और यहां, `3. c` को इंडेंटेड कोड ब्लॉक के रूप में माना जाता है, क्योंकि यह चार spaces इंडेंट है और खाली लाइन से पहले है।

```example
1. a

  2. b

    3. c
.
<ol>
<li>
<p>a</p>
</li>
<li>
<p>b</p>
</li>
</ol>
<pre><code>3. c
</code></pre>
```

यह एक loose list है, क्योंकि दो सूची आइटम्स के बीच खाली लाइन है:

```example
- a
- b

- c
.
<ul>
<li>
<p>a</p>
</li>
<li>
<p>b</p>
</li>
<li>
<p>c</p>
</li>
</ul>
```

यह भी ऐसा ही है, खाली दूसरे आइटम के साथ:

```example
* a
*

* c
.
<ul>
<li>
<p>a</p>
</li>
<li></li>
<li>
<p>c</p>
</li>
</ul>
```

ये loose lists हैं, भले ही आइटम्स के बीच कोई space नहीं है, क्योंकि आइटम्स में से एक में सीधे दो ब्लॉक-स्तरीय एलिमेंट्स हैं जिनके बीच खाली लाइन है:

```example
- a
- b

  c
- d
.
<ul>
<li>
<p>a</p>
</li>
<li>
<p>b</p>
<p>c</p>
</li>
<li>
<p>d</p>
</li>
</ul>
```

```example
- a
- b

  [ref]: /url
- d
.
<ul>
<li>
<p>a</p>
</li>
<li>
<p>b</p>
</li>
<li>
<p>d</p>
</li>
</ul>
```

यह एक tight list है, क्योंकि खाली लाइनें कोड ब्लॉक में हैं:

````example
- a
- ```
  b


  ```
- c
.
<ul>
<li>a</li>
<li>
<pre><code>b


</code></pre>
</li>
<li>c</li>
</ul>
````

यह एक tight list है, क्योंकि खाली लाइन sublist के दो पैराग्राफ के बीच है। इसलिए sublist loose है जबकि बाहरी सूची tight है:

```example
- a
  - b

    c
- d
.
<ul>
<li>a
<ul>
<li>
<p>b</p>
<p>c</p>
</li>
</ul>
</li>
<li>d</li>
</ul>
```

यह एक tight list है, क्योंकि खाली लाइन ब्लॉक कोट के अंदर है:

```example
* a
  > b
  >
* c
.
<ul>
<li>a
<blockquote>
<p>b</p>
</blockquote>
</li>
<li>c</li>
</ul>
```

यह सूची tight है, क्योंकि लगातार ब्लॉक एलिमेंट्स खाली लाइनों द्वारा अलग नहीं हैं:

````example
- a
  > b
  ```
  c
  ```
- d
.
<ul>
<li>a
<blockquote>
<p>b</p>
</blockquote>
<pre><code>c
</code></pre>
</li>
<li>d</li>
</ul>
````

single-paragraph list tight है:

```example
- a
.
<ul>
<li>a</li>
</ul>
```

```example
- a
  - b
.
<ul>
<li>a
<ul>
<li>b</li>
</ul>
</li>
</ul>
```

यह सूची loose है, क्योंकि सूची आइटम में दो ब्लॉक एलिमेंट्स के बीच खाली लाइन है:

````example
1. ```
   foo
   ```

   bar
.
<ol>
<li>
<pre><code>foo
</code></pre>
<p>bar</p>
</li>
</ol>
````

यहां बाहरी सूची loose है, आंतरिक सूची tight है:

```example
* foo
  * bar

  baz
.
<ul>
<li>
<p>foo</p>
<ul>
<li>bar</li>
</ul>
<p>baz</p>
</li>
</ul>
```

```example
- a
  - b
  - c

- d
  - e
  - f
.
<ul>
<li>
<p>a</p>
<ul>
<li>b</li>
<li>c</li>
</ul>
</li>
<li>
<p>d</p>
<ul>
<li>e</li>
<li>f</li>
</ul>
</li>
</ul>
```

# इनलाइन्स

Inlines को वर्ण stream की शुरुआत से अंत तक क्रमिक रूप से पार्स किया जाता है (बाएं से दाएं, बाएं से दाएं भाषाओं में)। इस प्रकार, उदाहरण के लिए,

```example
`hi`lo`
.
<p><code>hi</code>lo`</p>
```

में `hi` को code के रूप में पार्स किया जाता है, अंत में backtick को शाब्दिक backtick के रूप में छोड़ते हुए।

## Backslash escapes

किसी भी ASCII विराम चिह्न वर्ण को backslash-escaped किया जा सकता है:

```example
\!\"\#\$\%\&\'\(\)\*\+\,\-\.\/\:\;\<\=\>\?\@\[\\\]\^\_\`\{\|\}\~
.
<p>!&quot;#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~</p>
```

अन्य वर्णों से पहले Backslashes को शाब्दिक backslashes के रूप में माना जाता है:

```example
\→\A\a\ \3\φ\«
.
<p>\→\A\a\ \3\φ\«</p>
```

Escaped वर्णों को नियमित वर्णों के रूप में माना जाता है और उनके सामान्य Markdown अर्थ नहीं होते:

```example
\*not emphasized*
\<br/> not a tag
\[not a link](/foo)
\`not code`
1\. not a list
\* not a list
\# not a heading
\[foo]: /url "not a reference"
\&ouml; not a character entity
.
<p>*not emphasized*
&lt;br/&gt; not a tag
[not a link](/foo)
`not code`
1. not a list
* not a list
# not a heading
[foo]: /url &quot;not a reference&quot;
&amp;ouml; not a character entity</p>
```

यदि backslash स्वयं escaped है, तो निम्नलिखित वर्ण नहीं है:

```example
\\*emphasis*
.
<p>\<em>emphasis</em></p>
```

लाइन के अंत में backslash एक [hard line break] है:

```example
foo\
bar
.
<p>foo<br />
bar</p>
```

Backslash escapes कोड ब्लॉक्स, कोड स्पैन, autolinks, या raw HTML में काम नहीं करते:

```example
`` \[\` ``
.
<p><code>\[\`</code></p>
```

```example
    \[\]
.
<pre><code>\[\]
</code></pre>
```

```example
~~~
\[\]
~~~
.
<pre><code>\[\]
</code></pre>
```

```example
<http://example.com?find=\*>
.
<p><a href="http://example.com?find=%5C*">http://example.com?find=\*</a></p>
```

```example
<a href="/bar\/)">
.
<a href="/bar\/)">
```

लेकिन वे अन्य सभी संदर्भों में काम करते हैं, URLs और link titles, link references, और [fenced code blocks] में [info strings] सहित:

```example
[foo](/bar\* "ti\*tle")
.
<p><a href="/bar*" title="ti*tle">foo</a></p>
```

```example
[foo]

[foo]: /bar\* "ti\*tle"
.
<p><a href="/bar*" title="ti*tle">foo</a></p>
```

````example
``` foo\+bar
foo
```
.
<pre><code class="language-foo+bar">foo
</code></pre>
````

## एंटिटी और संख्यात्मक वर्ण संदर्भ

मान्य HTML entity references और numeric character references का उपयोग संबंधित Unicode वर्ण के स्थान पर किया जा सकता है, निम्नलिखित अपवादों के साथ:

- Entity और character references को कोड ब्लॉक्स और कोड स्पैन में पहचाना नहीं जाता है।

- Entity और character references उन विशेष वर्णों के स्थान पर नहीं हो सकते जो CommonMark में संरचनात्मक तत्वों को परिभाषित करते हैं। उदाहरण के लिए, यद्यपि `&#42;` का उपयोग शाब्दिक `*` वर्ण के स्थान पर किया जा सकता है, `&#42;` emphasis delimiters, bullet list markers, या thematic breaks में `*` को replace नहीं कर सकता।

अनुरूप CommonMark पार्सर को इस बारे में जानकारी संग्रहीत करने की आवश्यकता नहीं है कि किसी विशेष वर्ण को स्रोत में Unicode वर्ण या entity reference का उपयोग करके दर्शाया गया था।

[Entity references](@) में `&` + मान्य HTML5 entity names में से कोई भी + `;` शामिल हैं। दस्तावेज़ <https://html.spec.whatwg.org/multipage/entities.json> को मान्य entity references और उनके संबंधित code points के लिए एक आधिकारिक स्रोत के रूप में उपयोग किया जाता है।

```example
&nbsp; &amp; &copy; &AElig; &Dcaron;
&frac34; &HilbertSpace; &DifferentialD;
&ClockwiseContourIntegral; &ngE;
.
<p>  &amp; © Æ Ď
¾ ℋ ⅆ
∲ ≧̸</p>
```

[दशमलव संख्यात्मक वर्ण संदर्भ](@) में `&#` + 1--7 अरबी अंकों की एक स्ट्रिंग + `;` शामिल हैं। एक numeric character reference को संबंधित Unicode वर्ण के रूप में पार्स किया जाता है। अमान्य Unicode code points को REPLACEMENT CHARACTER (`U+FFFD`) से बदल दिया जाएगा। सुरक्षा कारणों से, code point `U+0000` को भी `U+FFFD` से बदल दिया जाएगा।

```example
&#35; &#1234; &#992; &#0;
.
<p># Ӓ Ϡ �</p>
```

[हेक्साडेसिमल संख्यात्मक वर्ण संदर्भ](@) में `&#` + या तो `X` या `x` + 1-6 हेक्साडेसिमल अंकों की एक स्ट्रिंग + `;` शामिल हैं। इन्हें भी संबंधित Unicode वर्ण के रूप में पार्स किया जाता है (इस बार दशमलव के बजाय हेक्साडेसिमल अंक के साथ निर्दिष्ट)।

```example
&#X22; &#XD06; &#xcab;
.
<p>&quot; ആ ಫ</p>
```

यहां कुछ nonentities हैं:

```example
&nbsp &x; &#; &#x;
&#987654321;
&#abcdef0;
&ThisIsNotDefined; &hi?;
.
<p>&amp;nbsp &amp;x; &amp;#; &amp;#x;
&amp;#987654321;
&amp;#abcdef0;
&amp;ThisIsNotDefined; &amp;hi?;</p>
```

यद्यपि HTML5 trailing semicolon के बिना कुछ entity references को स्वीकार करता है (जैसे `&copy`), इन्हें यहां पहचाना नहीं जाता है, क्योंकि यह grammar को बहुत अस्पष्ट बनाता है:

```example
&copy
.
<p>&amp;copy</p>
```

Strings जो HTML5 नामित entities की सूची में नहीं हैं उन्हें entity references के रूप में भी पहचाना नहीं जाता है:

```example
&MadeUpEntity;
.
<p>&amp;MadeUpEntity;</p>
```

Entity और numeric character references को कोड स्पैन या कोड ब्लॉक्स के अलावा किसी भी संदर्भ में पहचाना जाता है, URLs, [link titles], और [fenced code block][] [info strings] सहित:

```example
<a href="&ouml;&ouml;.html">
.
<a href="&ouml;&ouml;.html">
```

```example
[foo](/f&ouml;&ouml; "f&ouml;&ouml;")
.
<p><a href="/f%C3%B6%C3%B6" title="föö">foo</a></p>
```

```example
[foo]

[foo]: /f&ouml;&ouml; "f&ouml;&ouml;"
.
<p><a href="/f%C3%B6%C3%B6" title="föö">foo</a></p>
```

````example
``` f&ouml;&ouml;
foo
```
.
<pre><code class="language-föö">foo
</code></pre>
````

Entity और numeric character references को कोड स्पैन और कोड ब्लॉक्स में शाब्दिक टेक्स्ट के रूप में माना जाता है:

```example
`f&ouml;&ouml;`
.
<p><code>f&amp;ouml;&amp;ouml;</code></p>
```

```example
    f&ouml;f&ouml;
.
<pre><code>f&amp;ouml;f&amp;ouml;
</code></pre>
```

Entity और numeric character references का उपयोग CommonMark दस्तावेज़ों में संरचना को इंगित करने वाले प्रतीकों के स्थान पर नहीं किया जा सकता है।

```example
&#42;foo&#42;
*foo*
.
<p>*foo*
<em>foo</em></p>
```

```example
&#42; foo

* foo
.
<p>* foo</p>
<ul>
<li>foo</li>
</ul>
```

```example
foo&#10;&#10;bar
.
<p>foo

bar</p>
```

```example
&#9;foo
.
<p>→foo</p>
```

```example
[a](url &quot;tit&quot;)
.
<p>[a](url &quot;tit&quot;)</p>
```

## कोड स्पैन

एक [backtick string](@) एक या अधिक backtick वर्णों (`` ` ``) की एक स्ट्रिंग है जो न तो backtick से पहले है और न ही इसके बाद है।

एक [code span](@) backtick string से शुरू होता है और समान लंबाई की backtick string के साथ समाप्त होता है। कोड स्पैन की सामग्री दो backtick strings के बीच के वर्ण हैं, निम्नलिखित तरीकों से सामान्यीकृत:

- पहले, [line endings] को [spaces] में बदल दिया जाता है।
- यदि परिणामी स्ट्रिंग _और_ [space] वर्ण के साथ शुरू और समाप्त दोनों होती है, लेकिन पूरी तरह से [space] वर्णों से नहीं बनी है, तो एक single [space] वर्ण को सामने और पीछे से हटा दिया जाता है। यह आपको ऐसे कोड को शामिल करने की अनुमति देता है जो backtick वर्णों से शुरू या समाप्त होता है, जिन्हें शुरुआती या समापन backtick strings से whitespace द्वारा अलग किया जाना चाहिए।

यह एक सरल code span है:

```example
`foo`
.
<p><code>foo</code></p>
```

यहां दो backticks का उपयोग किया जाता है, क्योंकि कोड में backtick है। यह उदाहरण एक single अग्रणी और अनुगामी space की stripping को भी illustrate करता है:

```example
`` foo ` bar ``
.
<p><code>foo ` bar</code></p>
```

यह उदाहरण अग्रणी और अनुगामी spaces को stripping करने की प्रेरणा दिखाता है:

```example
` `` `
.
<p><code>``</code></p>
```

ध्यान दें कि केवल _एक_ space stripped है:

```example
`  ``  `
.
<p><code> `` </code></p>
```

stripping केवल तब होती है जब space स्ट्रिंग के दोनों तरफ हो:

```example
` a`
.
<p><code> a</code></p>
```

केवल [spaces], और सामान्य रूप से [unicode whitespace] नहीं, इस तरह से stripped हैं:

```example
` b `
.
<p><code> b </code></p>
```

यदि code span में केवल spaces हैं तो कोई stripping नहीं होती:

```example
` `
`  `
.
<p><code> </code>
<code>  </code></p>
```

[Line endings] को spaces की तरह माना जाता है:

```example
``
foo
bar
baz
``
.
<p><code>foo bar   baz</code></p>
```

```example
``
foo
``
.
<p><code>foo </code></p>
```

आंतरिक spaces collapsed नहीं हैं:

```example
`foo   bar
baz`
.
<p><code>foo   bar  baz</code></p>
```

ध्यान दें कि ब्राउज़र आमतौर पर `<code>` एलिमेंट्स को रेंडर करते समय लगातार spaces को collapse कर देंगे, इसलिए यह अनुशंसा की जाती है कि निम्नलिखित CSS का उपयोग किया जाए:

    code{white-space: pre-wrap;}

ध्यान दें कि backslash escapes कोड स्पैन में काम नहीं करते। सभी backslashes को शाब्दिक रूप से माना जाता है:

```example
`foo\`bar`
.
<p><code>foo\</code>bar`</p>
```

Backslash escapes की कभी आवश्यकता नहीं है, क्योंकि कोई हमेशा delimiters के रूप में _n_ backtick वर्णों की एक स्ट्रिंग चुन सकता है, जहां कोड में बिल्कुल _n_ backtick वर्णों की कोई स्ट्रिंग नहीं है।

```example
``foo`bar``
.
<p><code>foo`bar</code></p>
```

```example
` foo `` bar `
.
<p><code>foo `` bar</code></p>
```

Code span backticks को HTML टैग्स और autolinks को छोड़कर किसी भी अन्य इनलाइन कंस्ट्रक्ट्स की तुलना में उच्च प्राथमिकता है। इस प्रकार, उदाहरण के लिए, यह emphasized टेक्स्ट के रूप में पार्स नहीं है, क्योंकि दूसरा `*` कोड स्पैन का हिस्सा है:

```example
*foo`*`
.
<p>*foo<code>*</code></p>
```

और यह लिंक के रूप में पार्स नहीं है:

```example
[not a `link](/foo`)
.
<p>[not a <code>link](/foo</code>)</p>
```

Code spans, HTML टैग्स, और autolinks की समान प्राथमिकता है। इस प्रकार, यह code है:

```example
`<a href="`">`
.
<p><code>&lt;a href=&quot;</code>&quot;&gt;`</p>
```

लेकिन यह HTML टैग है:

```example
<a href="`">`
.
<p><a href="`">`</p>
```

और यह code है:

```example
`<http://foo.bar.`baz>`
.
<p><code>&lt;http://foo.bar.</code>baz&gt;`</p>
```

लेकिन यह autolink है:

```example
<http://foo.bar.`baz>`
.
<p><a href="http://foo.bar.%60baz">http://foo.bar.`baz</a>`</p>
```

जब backtick string को मिलती backtick string द्वारा बंद नहीं किया जाता है, तो हमारे पास केवल शाब्दिक backticks हैं:

````example
```foo``
.
<p>```foo``</p>
````

```example
`foo
.
<p>`foo</p>
```

निम्नलिखित मामला शुरुआती और समापन backtick strings के समान लंबाई के होने की आवश्यकता को भी illustrate करता है:

```example
`foo``bar``
.
<p>`foo<code>bar</code></p>
```

## ज़ोर और strong ज़ोर

John Gruber का मूल [Markdown सिंटैक्स विवरण](http://daringfireball.net/projects/markdown/syntax#em) कहता है:

> Markdown asterisks (`*`) और underscores (`_`) को ज़ोर के संकेतक के रूप में मानता है। एक `*` या `_` के साथ wrapped टेक्स्ट को HTML `<em>` टैग के साथ wrapped किया जाएगा; double `*`'s या `_`'s को HTML `<strong>` टैग के साथ wrapped किया जाएगा।

यह अधिकांश उपयोगकर्ताओं के लिए पर्याप्त है, लेकिन ये नियम बहुत कुछ अनिर्णीत छोड़ देते हैं, विशेष रूप से जब नेस्टेड ज़ोर की बात आती है। मूल `Markdown.pl` test suite यह स्पष्ट करता है कि triple `***` और `___` delimiters का उपयोग strong emphasis के लिए किया जा सकता है, और अधिकांश कार्यान्वयनों ने निम्नलिखित पैटर्न की भी अनुमति दी है:

```markdown
**_strong emph_**
**\*strong** in emph\*
**_emph_ in strong**
**in strong _emph_**
\*in emph **strong\***
```

निम्नलिखित पैटर्न कम व्यापक रूप से समर्थित हैं, लेकिन इरादा स्पष्ट है और वे उपयोगी हैं (विशेष रूप से संदर्भ ग्रंथ सूची प्रविष्टियों जैसे संदर्भों में):

```markdown
*emph *with emph* in it*
**strong **with strong** in it**
```

कई कार्यान्वयनों ने आंतरिक underscores युक्त शब्दों में अवांछित ज़ोर से बचने के लिए intraword emphasis को `*` forms तक सीमित किया है। (इन्हें code spans में डालना सर्वोत्तम अभ्यास है, लेकिन उपयोगकर्ता अक्सर नहीं करते।)

```markdown
internal emphasis: foo*bar*baz
no emphasis: foo_bar_baz
```

नीचे दिए गए नियम इन सभी पैटर्न को capture करते हैं, जबकि कुशल parsing रणनीतियों की अनुमति देते हैं जो backtrack नहीं करती हैं।

पहले, कुछ परिभाषाएं। एक [delimiter run](@) या तो एक या अधिक `*` वर्णों का एक अनुक्रम है जो non-backslash-escaped `*` वर्ण से पहले या बाद में नहीं है, या एक या अधिक `_` वर्णों का एक अनुक्रम है जो non-backslash-escaped `_` वर्ण से पहले या बाद में नहीं है।

एक [left-flanking delimiter run](@) एक [delimiter run] है जो (1) [Unicode whitespace] के बाद नहीं है, और या तो (2a) [punctuation character] के बाद नहीं है, या (2b) [punctuation character] के बाद है और [Unicode whitespace] या [punctuation character] से पहले है। इस परिभाषा के उद्देश्यों के लिए, लाइन की शुरुआत और अंत को Unicode whitespace के रूप में गिना जाता है।

एक [right-flanking delimiter run](@) एक [delimiter run] है जो (1) [Unicode whitespace] से पहले नहीं है, और या तो (2a) [punctuation character] से पहले नहीं है, या (2b) [punctuation character] से पहले है और [Unicode whitespace] या [punctuation character] के बाद है। इस परिभाषा के उद्देश्यों के लिए, लाइन की शुरुआत और अंत को Unicode whitespace के रूप में गिना जाता है।

यहां delimiter runs के कुछ उदाहरण हैं।

- left-flanking लेकिन right-flanking नहीं:

  ```
  ***abc
    _abc
  **"abc"
   _"abc"
  ```

- right-flanking लेकिन left-flanking नहीं:

  ```
   abc***
   abc_
  "abc"**
  "abc"_
  ```

- left और right-flanking दोनों:

  ```
   abc***def
  "abc"_"def"
  ```

- न left न right-flanking:

  ```
  abc *** def
  a _ b
  ```

(पहले और बाद के वर्ण के आधार पर left-flanking और right-flanking delimiter runs को अलग करने का विचार Roopesh Chander के [vfmd](http://www.vfmd.org/vfmd-spec/specification/#procedure-for-identifying-emphasis-tags) से आता है। vfmd "delimiter run" के बजाय "emphasis indicator string" शब्दावली का उपयोग करता है, और left- और right-flanking runs को अलग करने के लिए इसके नियम यहां दिए गए नियमों की तुलना में थोड़े अधिक जटिल हैं।)

निम्नलिखित नियम ज़ोर और strong ज़ोर को परिभाषित करते हैं:

1.  एक single `*` वर्ण [can open emphasis](@) iff (if and only if) यह [left-flanking delimiter run] का हिस्सा है।

2.  एक single `_` वर्ण [can open emphasis] iff यह [left-flanking delimiter run] का हिस्सा है और या तो (a) [right-flanking delimiter run] का हिस्सा नहीं है या (b) विराम चिह्न से पहले [right-flanking delimiter run] का हिस्सा है।

3.  एक single `*` वर्ण [can close emphasis](@) iff यह [right-flanking delimiter run] का हिस्सा है।

4.  एक single `_` वर्ण [can close emphasis] iff यह [right-flanking delimiter run] का हिस्सा है और या तो (a) [left-flanking delimiter run] का हिस्सा नहीं है या (b) विराम चिह्न के बाद [left-flanking delimiter run] का हिस्सा है।

5.  एक double `**` [can open strong emphasis](@) iff यह [left-flanking delimiter run] का हिस्सा है।

6.  एक double `__` [can open strong emphasis] iff यह [left-flanking delimiter run] का हिस्सा है और या तो (a) [right-flanking delimiter run] का हिस्सा नहीं है या (b) विराम चिह्न से पहले [right-flanking delimiter run] का हिस्सा है।

7.  एक double `**` [can close strong emphasis](@) iff यह [right-flanking delimiter run] का हिस्सा है।

8.  एक double `__` [can close strong emphasis] iff यह [right-flanking delimiter run] का हिस्सा है और या तो (a) [left-flanking delimiter run] का हिस्सा नहीं है या (b) विराम चिह्न के बाद [left-flanking delimiter run] का हिस्सा है।

9.  ज़ोर एक delimiter के साथ शुरू होता है जो [can open emphasis] और एक delimiter के साथ समाप्त होता है जो [can close emphasis], और जो शुरुआती delimiter के समान वर्ण (`_` या `*`) का उपयोग करता है। शुरुआती और समापन delimiters अलग [delimiter runs] से संबंधित होने चाहिए। यदि delimiters में से एक ज़ोर को open और close दोनों कर सकता है, तो शुरुआती और समापन delimiters युक्त delimiter runs की लंबाइयों का योग 3 का गुणज नहीं होना चाहिए जब तक कि दोनों लंबाइयां 3 के गुणज न हों।

10. Strong emphasis एक delimiter के साथ शुरू होता है जो [can open strong emphasis] और एक delimiter के साथ समाप्त होता है जो [can close strong emphasis], और जो शुरुआती delimiter के समान वर्ण (`_` या `*`) का उपयोग करता है। शुरुआती और समापन delimiters अलग [delimiter runs] से संबंधित होने चाहिए। यदि delimiters में से एक strong emphasis को open और close दोनों कर सकता है, तो शुरुआती और समापन delimiters युक्त delimiter runs की लंबाइयों का योग 3 का गुणज नहीं होना चाहिए जब तक कि दोनों लंबाइयां 3 के गुणज न हों।

11. एक शाब्दिक `*` वर्ण `*`-delimited emphasis या `**`-delimited strong emphasis की शुरुआत या अंत में नहीं हो सकता, जब तक कि यह backslash-escaped न हो।

12. एक शाब्दिक `_` वर्ण `_`-delimited emphasis या `__`-delimited strong emphasis की शुरुआत या अंत में नहीं हो सकता, जब तक कि यह backslash-escaped न हो।

जहां ऊपर दिए गए नियम 1--12 कई parsings के साथ compatible हैं, निम्नलिखित सिद्धांत अस्पष्टता को हल करते हैं:

13. nesting की संख्या को कम से कम किया जाना चाहिए। इस प्रकार, उदाहरण के लिए, एक व्याख्या `<strong>...</strong>` को हमेशा `<em><em>...</em></em>` पर प्राथमिकता दी जाती है।

14. एक व्याख्या `<em><strong>...</strong></em>` को हमेशा `<strong><em>...</em></strong>` पर प्राथमिकता दी जाती है।

15. जब दो संभावित emphasis या strong emphasis spans ओवरलैप होते हैं, ताकि दूसरा पहले समाप्त होने से पहले शुरू हो और पहले समाप्त होने के बाद समाप्त हो, तो पहले को प्राथमिकता मिलती है। इस प्रकार, उदाहरण के लिए, `*foo _bar* baz_` को `<em>foo _bar</em> baz_` के रूप में पार्स किया जाता है न कि `*foo <em>bar* baz</em>` के रूप में।

16. जब समान समापन delimiter के साथ दो संभावित emphasis या strong emphasis spans हैं, तो छोटा वाला (जो बाद में खुलता है) को प्राथमिकता मिलती है। इस प्रकार, उदाहरण के लिए, `**foo **bar baz**` को `**foo <strong>bar baz</strong>` के रूप में पार्स किया जाता है न कि `<strong>foo **bar baz</strong>` के रूप में।

17. Inline code spans, links, images, और HTML टैग्स ज़ोर की तुलना में अधिक कसकर group होते हैं। इसलिए, जब एक व्याख्या के बीच विकल्प होता है जिसमें इन एलिमेंट्स में से एक होता है और एक जिसमें नहीं होता है, तो पहला हमेशा जीतता है। इस प्रकार, उदाहरण के लिए, `*[foo*](bar)` को `*<a href="bar">foo*</a>` के रूप में पार्स किया जाता है न कि `<em>[foo</em>](bar)` के रूप में।

इन नियमों को उदाहरणों की एक श्रृंखला के माध्यम से illustrate किया जा सकता है।

नियम 1:

```example
*foo bar*
.
<p><em>foo bar</em></p>
```

यह ज़ोर नहीं है, क्योंकि शुरुआती `*` के बाद whitespace है, और इसलिए [left-flanking delimiter run] का हिस्सा नहीं है:

```example
a * foo bar*
.
<p>a * foo bar*</p>
```

यह ज़ोर नहीं है, क्योंकि शुरुआती `*` से पहले alphanumeric है और इसके बाद विराम चिह्न है, और इसलिए [left-flanking delimiter run] का हिस्सा नहीं है:

```example
a*"foo"*
.
<p>a*&quot;foo&quot;*</p>
```

Unicode nonbreaking spaces भी whitespace के रूप में गिनते हैं:

```example
* a *
.
<p>* a *</p>
```

`*` के साथ Intraword emphasis की अनुमति है:

```example
foo*bar*
.
<p>foo<em>bar</em></p>
```

```example
5*6*78
.
<p>5<em>6</em>78</p>
```

नियम 2:

```example
_foo bar_
.
<p><em>foo bar</em></p>
```

यह ज़ोर नहीं है, क्योंकि शुरुआती `_` के बाद whitespace है:

```example
_ foo bar_
.
<p>_ foo bar_</p>
```

यह ज़ोर नहीं है, क्योंकि शुरुआती `_` से पहले alphanumeric है और इसके बाद विराम चिह्न है:

```example
a_"foo"_
.
<p>a_&quot;foo&quot;_</p>
```

`_` के साथ ज़ोर शब्दों के अंदर अनुमति नहीं है:

```example
foo_bar_
.
<p>foo_bar_</p>
```

```example
5_6_78
.
<p>5_6_78</p>
```

```example
пристаням_стремятся_
.
<p>пристаням_стремятся_</p>
```

यहां `_` ज़ोर उत्पन्न नहीं करता, क्योंकि पहला delimiter run right-flanking है और दूसरा left-flanking:

```example
aa_"bb"_cc
.
<p>aa_&quot;bb&quot;_cc</p>
```

यह ज़ोर है, भले ही शुरुआती delimiter left- और right-flanking दोनों है, क्योंकि यह विराम चिह्न से पहले है:

```example
foo-_(bar)_
.
<p>foo-<em>(bar)</em></p>
```

नियम 3:

यह ज़ोर नहीं है, क्योंकि समापन delimiter शुरुआती delimiter से मेल नहीं खाता:

```example
_foo*
.
<p>_foo*</p>
```

यह ज़ोर नहीं है, क्योंकि समापन `*` से पहले whitespace है:

```example
*foo bar *
.
<p>*foo bar *</p>
```

एक newline भी whitespace के रूप में गिनती है:

```example
*foo bar
*
.
<p>*foo bar
*</p>
```

यह ज़ोर नहीं है, क्योंकि दूसरा `*` विराम चिह्न से पहले है और alphanumeric के बाद है (इसलिए यह [right-flanking delimiter run] का हिस्सा नहीं है:

```example
*(*foo)
.
<p>*(*foo)</p>
```

इस प्रतिबंध का बिंदु इस उदाहरण के साथ अधिक आसानी से सराहा जाता है:

```example
*(*foo*)*
.
<p><em>(<em>foo</em>)</em></p>
```

`*` के साथ Intraword emphasis की अनुमति है:

```example
*foo*bar
.
<p><em>foo</em>bar</p>
```

नियम 4:

यह ज़ोर नहीं है, क्योंकि समापन `_` से पहले whitespace है:

```example
_foo bar _
.
<p>_foo bar _</p>
```

यह ज़ोर नहीं है, क्योंकि दूसरा `_` विराम चिह्न से पहले है और alphanumeric के बाद है:

```example
_(_foo)
.
<p>_(_foo)</p>
```

यह ज़ोर के भीतर ज़ोर है:

```example
_(_foo_)_
.
<p><em>(<em>foo</em>)</em></p>
```

`_` के लिए Intraword emphasis अनुमति नहीं है:

```example
_foo_bar
.
<p>_foo_bar</p>
```

```example
_пристаням_стремятся
.
<p>_пристаням_стремятся</p>
```

```example
_foo_bar_baz_
.
<p><em>foo_bar_baz</em></p>
```

यह ज़ोर है, भले ही समापन delimiter left- और right-flanking दोनों है, क्योंकि यह विराम चिह्न के बाद है:

```example
_(bar)_.
.
<p><em>(bar)</em>.</p>
```

नियम 5:

```example
**foo bar**
.
<p><strong>foo bar</strong></p>
```

यह strong emphasis नहीं है, क्योंकि शुरुआती delimiter के बाद whitespace है:

```example
** foo bar**
.
<p>** foo bar**</p>
```

यह strong emphasis नहीं है, क्योंकि शुरुआती `**` से पहले alphanumeric है और इसके बाद विराम चिह्न है, और इसलिए [left-flanking delimiter run] का हिस्सा नहीं है:

```example
a**"foo"**
.
<p>a**&quot;foo&quot;**</p>
```

`**` के साथ Intraword strong emphasis की अनुमति है:

```example
foo**bar**
.
<p>foo<strong>bar</strong></p>
```

नियम 6:

```example
__foo bar__
.
<p><strong>foo bar</strong></p>
```

यह strong emphasis नहीं है, क्योंकि शुरुआती delimiter के बाद whitespace है:

```example
__ foo bar__
.
<p>__ foo bar__</p>
```

एक newline whitespace के रूप में गिनती है:

```example
__
foo bar__
.
<p>__
foo bar__</p>
```

यह strong emphasis नहीं है, क्योंकि शुरुआती `__` से पहले alphanumeric है और इसके बाद विराम चिह्न है:

```example
a__"foo"__
.
<p>a__&quot;foo&quot;__</p>
```

`__` के साथ Intraword strong emphasis अनुमति नहीं है:

```example
foo__bar__
.
<p>foo__bar__</p>
```

```example
5__6__78
.
<p>5__6__78</p>
```

```example
пристаням__стремятся__
.
<p>пристаням__стремятся__</p>
```

```example
__foo, __bar__, baz__
.
<p><strong>foo, bar, baz</strong></p>
```

यह strong emphasis है, भले ही शुरुआती delimiter left- और right-flanking दोनों है, क्योंकि यह विराम चिह्न से पहले है:

```example
foo-__(bar)__
.
<p>foo-<strong>(bar)</strong></p>
```

नियम 7:

यह strong emphasis नहीं है, क्योंकि समापन delimiter से पहले whitespace है:

```example
**foo bar **
.
<p>**foo bar **</p>
```

(न ही इसे एक emphasized `*foo bar *` के रूप में व्याख्यायित किया जा सकता है, नियम 11 के कारण।)

यह strong emphasis नहीं है, क्योंकि दूसरा `**` विराम चिह्न से पहले है और alphanumeric के बाद है:

```example
**(**foo)
.
<p>**(**foo)</p>
```

इस प्रतिबंध का बिंदु इन उदाहरणों के साथ अधिक आसानी से सराहा जाता है:

```example
*(**foo**)*
.
<p><em>(<strong>foo</strong>)</em></p>
```

```example
**Gomphocarpus (*Gomphocarpus physocarpus*, syn.
*Asclepias physocarpa*)**
.
<p><strong>Gomphocarpus (<em>Gomphocarpus physocarpus</em>, syn.
<em>Asclepias physocarpa</em>)</strong></p>
```

```example
**foo "*bar*" foo**
.
<p><strong>foo &quot;<em>bar</em>&quot; foo</strong></p>
```

Intraword emphasis:

```example
**foo**bar
.
<p><strong>foo</strong>bar</p>
```

नियम 8:

यह strong emphasis नहीं है, क्योंकि समापन delimiter से पहले whitespace है:

```example
__foo bar __
.
<p>__foo bar __</p>
```

यह strong emphasis नहीं है, क्योंकि दूसरा `__` विराम चिह्न से पहले है और alphanumeric के बाद है:

```example
__(__foo)
.
<p>__(__foo)</p>
```

इस प्रतिबंध का बिंदु इस उदाहरण के साथ अधिक आसानी से सराहा जाता है:

```example
_(__foo__)_
.
<p><em>(<strong>foo</strong>)</em></p>
```

`__` के साथ Intraword strong emphasis अनुमति नहीं है:

```example
__foo__bar
.
<p>__foo__bar</p>
```

```example
__пристаням__стремятся
.
<p>__пристаням__стремятся</p>
```

```example
__foo__bar__baz__
.
<p><strong>foo__bar__baz</strong></p>
```

यह strong emphasis है, भले ही समापन delimiter left- और right-flanking दोनों है, क्योंकि यह विराम चिह्न के बाद है:

```example
__(bar)__.
.
<p><strong>(bar)</strong>.</p>
```

नियम 9:

इनलाइन एलिमेंट्स का कोई भी nonempty अनुक्रम एक emphasized span की सामग्री हो सकता है।

```example
*foo [bar](/url)*
.
<p><em>foo <a href="/url">bar</a></em></p>
```

```example
*foo
bar*
.
<p><em>foo
bar</em></p>
```

विशेष रूप से, ज़ोर और strong ज़ोर को ज़ोर के अंदर nested किया जा सकता है:

```example
_foo __bar__ baz_
.
<p><em>foo <strong>bar</strong> baz</em></p>
```

```example
_foo _bar_ baz_
.
<p><em>foo <em>bar</em> baz</em></p>
```

```example
__foo_ bar_
.
<p><em><em>foo</em> bar</em></p>
```

```example
*foo *bar**
.
<p><em>foo <em>bar</em></em></p>
```

```example
*foo **bar** baz*
.
<p><em>foo <strong>bar</strong> baz</em></p>
```

```example
*foo**bar**baz*
.
<p><em>foo<strong>bar</strong>baz</em></p>
```

ध्यान दें कि पूर्ववर्ती मामले में, व्याख्या

```markdown
<p><em>foo</em><em>bar<em></em>baz</em></p>
```

इस शर्त द्वारा precluded है कि एक delimiter जो open और close दोनों कर सकता है (जैसे `foo` के बाद `*`) ज़ोर नहीं बना सकता यदि शुरुआती और समापन delimiters युक्त delimiter runs की लंबाइयों का योग 3 का गुणज है जब तक कि दोनों लंबाइयां 3 के गुणज न हों।

इसी कारण से, हमें इस उदाहरण में दो लगातार ज़ोर अनुभाग नहीं मिलते:

```example
*foo**bar*
.
<p><em>foo**bar</em></p>
```

समान शर्त सुनिश्चित करती है कि निम्नलिखित मामले सभी ज़ोर के अंदर nested strong ज़ोर हैं, भले ही आंतरिक spaces को छोड़ दिया गया हो:

```example
***foo** bar*
.
<p><em><strong>foo</strong> bar</em></p>
```

```example
*foo **bar***
.
<p><em>foo <strong>bar</strong></em></p>
```

```example
*foo**bar***
.
<p><em>foo<strong>bar</strong></em></p>
```

जब आंतरिक समापन और शुरुआती delimiter runs की लंबाइयां _दोनों_ 3 के गुणज हैं, हालांकि, वे ज़ोर बनाने के लिए मेल खा सकते हैं:

```example
foo***bar***baz
.
<p>foo<em><strong>bar</strong></em>baz</p>
```

```example
foo******bar*********baz
.
<p>foo<strong>bar</strong>***baz</p>
```

nesting के अनिश्चित स्तर संभव हैं:

```example
*foo **bar *baz* bim** bop*
.
<p><em>foo <strong>bar <em>baz</em> bim</strong> bop</em></p>
```

```example
*foo [*bar*](/url)*
.
<p><em>foo <a href="/url"><em>bar</em></a></em></p>
```

कोई खाली ज़ोर या strong ज़ोर नहीं हो सकता:

```example
** is not an empty emphasis
.
<p>** is not an empty emphasis</p>
```

```example
**** is not an empty strong emphasis
.
<p>**** is not an empty strong emphasis</p>
```

नियम 10:

इनलाइन एलिमेंट्स का कोई भी nonempty अनुक्रम strongly emphasized span की सामग्री हो सकता है।

```example
**foo [bar](/url)**
.
<p><strong>foo <a href="/url">bar</a></strong></p>
```

```example
**foo
bar**
.
<p><strong>foo
bar</strong></p>
```

विशेष रूप से, ज़ोर और strong ज़ोर को strong ज़ोर के अंदर nested किया जा सकता है:

```example
__foo _bar_ baz__
.
<p><strong>foo <em>bar</em> baz</strong></p>
```

```example
__foo __bar__ baz__
.
<p><strong>foo bar baz</strong></p>
```

```example
____foo__ bar__
.
<p><strong>foo bar</strong></p>
```

```example
**foo **bar****
.
<p><strong>foo bar</strong></p>
```

```example
**foo *bar* baz**
.
<p><strong>foo <em>bar</em> baz</strong></p>
```

```example
**foo*bar*baz**
.
<p><strong>foo<em>bar</em>baz</strong></p>
```

```example
***foo* bar**
.
<p><strong><em>foo</em> bar</strong></p>
```

```example
**foo *bar***
.
<p><strong>foo <em>bar</em></strong></p>
```

nesting के अनिश्चित स्तर संभव हैं:

```example
**foo *bar **baz**
bim* bop**
.
<p><strong>foo <em>bar <strong>baz</strong>
bim</em> bop</strong></p>
```

```example
**foo [*bar*](/url)**
.
<p><strong>foo <a href="/url"><em>bar</em></a></strong></p>
```

कोई खाली ज़ोर या strong ज़ोर नहीं हो सकता:

```example
__ is not an empty emphasis
.
<p>__ is not an empty emphasis</p>
```

```example
____ is not an empty strong emphasis
.
<p>____ is not an empty strong emphasis</p>
```

नियम 11:

```example
foo ***
.
<p>foo ***</p>
```

```example
foo *\**
.
<p>foo <em>*</em></p>
```

```example
foo *_*
.
<p>foo <em>_</em></p>
```

```example
foo *****
.
<p>foo *****</p>
```

```example
foo **\***
.
<p>foo <strong>*</strong></p>
```

```example
foo **_**
.
<p>foo <strong>_</strong></p>
```

ध्यान दें कि जब delimiters समान रूप से मेल नहीं खाते, तो नियम 11 यह निर्धारित करता है कि अतिरिक्त शाब्दिक `*` वर्ण ज़ोर के अंदर के बजाय बाहर दिखाई देंगे:

```example
**foo*
.
<p>*<em>foo</em></p>
```

```example
*foo**
.
<p><em>foo</em>*</p>
```

```example
***foo**
.
<p>*<strong>foo</strong></p>
```

```example
****foo*
.
<p>***<em>foo</em></p>
```

```example
**foo***
.
<p><strong>foo</strong>*</p>
```

```example
*foo****
.
<p><em>foo</em>***</p>
```

नियम 12:

```example
foo ___
.
<p>foo ___</p>
```

```example
foo _\__
.
<p>foo <em>_</em></p>
```

```example
foo _*_
.
<p>foo <em>*</em></p>
```

```example
foo _____
.
<p>foo _____</p>
```

```example
foo __\___
.
<p>foo <strong>_</strong></p>
```

```example
foo __*__
.
<p>foo <strong>*</strong></p>
```

```example
__foo_
.
<p>_<em>foo</em></p>
```

ध्यान दें कि जब delimiters समान रूप से मेल नहीं खाते, तो नियम 12 यह निर्धारित करता है कि अतिरिक्त शाब्दिक `_` वर्ण ज़ोर के अंदर के बजाय बाहर दिखाई देंगे:

```example
_foo__
.
<p><em>foo</em>_</p>
```

```example
___foo__
.
<p>_<strong>foo</strong></p>
```

```example
____foo_
.
<p>___<em>foo</em></p>
```

```example
__foo___
.
<p><strong>foo</strong>_</p>
```

```example
_foo____
.
<p><em>foo</em>___</p>
```

नियम 13 implies करता है कि यदि आप ज़ोर को सीधे ज़ोर के अंदर nested चाहते हैं, तो आपको अलग delimiters का उपयोग करना होगा:

```example
**foo**
.
<p><strong>foo</strong></p>
```

```example
*_foo_*
.
<p><em><em>foo</em></em></p>
```

```example
__foo__
.
<p><strong>foo</strong></p>
```

```example
_*foo*_
.
<p><em><em>foo</em></em></p>
```

हालांकि, strong ज़ोर के भीतर strong ज़ोर delimiters बदले बिना संभव है:

```example
****foo****
.
<p><strong>foo</strong></p>
```

```example
____foo____
.
<p><strong>foo</strong></p>
```

नियम 13 को delimiters के मनमाने रूप से लंबे अनुक्रमों पर लागू किया जा सकता है:

```example
******foo******
.
<p><strong>foo</strong></p>
```

नियम 14:

```example
***foo***
.
<p><em><strong>foo</strong></em></p>
```

```example
_____foo_____
.
<p><em><strong>foo</strong></em></p>
```

नियम 15:

```example
*foo _bar* baz_
.
<p><em>foo _bar</em> baz_</p>
```

```example
*foo __bar *baz bim__ bam*
.
<p><em>foo <strong>bar *baz bim</strong> bam</em></p>
```

नियम 16:

```example
**foo **bar baz**
.
<p>**foo <strong>bar baz</strong></p>
```

```example
*foo *bar baz*
.
<p>*foo <em>bar baz</em></p>
```

नियम 17:

```example
*[bar*](/url)
.
<p>*<a href="/url">bar*</a></p>
```

```example
_foo [bar_](/url)
.
<p>_foo <a href="/url">bar_</a></p>
```

```example
*<img src="foo" title="*"/>
.
<p>*<img src="foo" title="*"/></p>
```

```example
**<a href="**">
.
<p>**<a href="**"></p>
```

```example
__<a href="__">
.
<p>__<a href="__"></p>
```

```example
*a `*`*
.
<p><em>a <code>*</code></em></p>
```

```example
_a `_`_
.
<p><em>a <code>_</code></em></p>
```

```example
**a<http://foo.bar/?q=**>
.
<p>**a<a href="http://foo.bar/?q=**">http://foo.bar/?q=**</a></p>
```

```example
__a<http://foo.bar/?q=__>
.
<p>__a<a href="http://foo.bar/?q=__">http://foo.bar/?q=__</a></p>
```

<div class="extension">

## स्ट्राइकथ्रू (एक्सटेंशन)

GFM `strikethrough` एक्सटेंशन को सक्षम करता है, जहां एक अतिरिक्त ज़ोर प्रकार उपलब्ध है।

स्ट्राइकथ्रू टेक्स्ट कोई भी टेक्स्ट है जो दो tildes (`~`) में wrapped है।

```example strikethrough
~~Hi~~ Hello, world!
.
<p><del>Hi</del> Hello, world!</p>
```

नियमित emphasis delimiters की तरह, एक नया पैराग्राफ strikethrough पार्सिंग को रोक देगा:

```example strikethrough
This ~~has a

new paragraph~~.
.
<p>This ~~has a</p>
<p>new paragraph~~.</p>
```

</div>

## लिंक्स

एक लिंक में [link text] (दृश्य टेक्स्ट), एक [link destination] (URI जो लिंक destination है), और वैकल्पिक रूप से एक [link title] होता है। Markdown में दो बुनियादी प्रकार के लिंक्स हैं। [inline links] में destination और title लिंक टेक्स्ट के तुरंत बाद दिए जाते हैं। [reference links] में destination और title दस्तावेज़ में कहीं और परिभाषित किए जाते हैं।

एक [link text](@) square brackets (`[` और `]`) द्वारा enclosed शून्य या अधिक इनलाइन एलिमेंट्स के एक अनुक्रम से बना है। निम्नलिखित नियम लागू होते हैं:

- लिंक्स में किसी भी स्तर की nesting पर अन्य लिंक्स नहीं हो सकते। यदि कई अन्यथा मान्य लिंक परिभाषाएं एक-दूसरे के अंदर nested दिखाई देती हैं, तो सबसे भीतरी परिभाषा का उपयोग किया जाता है।

- [link text] में Brackets की अनुमति केवल तभी है यदि (a) वे backslash-escaped हैं या (b) वे brackets की एक मिलती-जुलती जोड़ी के रूप में दिखाई देते हैं, एक open bracket `[`, शून्य या अधिक inlines का एक अनुक्रम, और एक close bracket `]` के साथ।

- Backtick [code spans], [autolinks], और raw [HTML tags] लिंक टेक्स्ट में brackets की तुलना में अधिक कसकर bind होते हैं। इस प्रकार, उदाहरण के लिए, `` [foo`]` `` लिंक टेक्स्ट नहीं हो सकता, क्योंकि दूसरा `]` code span का हिस्सा है।

- लिंक टेक्स्ट में brackets [emphasis and strong emphasis] के markers की तुलना में अधिक कसकर bind होते हैं। इस प्रकार, उदाहरण के लिए, `*[foo*](url)` एक लिंक है।

एक [link destination](@) या तो इनमें से बना है

- एक शुरुआती `<` और एक समापन `>` के बीच शून्य या अधिक वर्णों का एक अनुक्रम जिसमें कोई line breaks या unescaped `<` या `>` वर्ण नहीं हैं, या

- वर्णों का एक nonempty अनुक्रम जो `<` से शुरू नहीं होता, ASCII space या control characters शामिल नहीं करता, और parentheses केवल तभी शामिल करता है यदि (a) वे backslash-escaped हैं या (b) वे unescaped parentheses की संतुलित जोड़ी का हिस्सा हैं। (कार्यान्वयन प्रदर्शन मुद्दों से बचने के लिए parentheses nesting पर सीमाएं लगा सकते हैं, लेकिन कम से कम तीन स्तर की nesting समर्थित होनी चाहिए।)

एक [link title](@) या तो इनमें से बना है

- सीधे double-quote वर्णों (`"`) के बीच शून्य या अधिक वर्णों का एक अनुक्रम, `"` वर्ण केवल तभी शामिल करता है यदि यह backslash-escaped है, या

- सीधे single-quote वर्णों (`'`) के बीच शून्य या अधिक वर्णों का एक अनुक्रम, `'` वर्ण केवल तभी शामिल करता है यदि यह backslash-escaped है, या

- मिलते parentheses (`(...)`) के बीच शून्य या अधिक वर्णों का एक अनुक्रम, `(` या `)` वर्ण केवल तभी शामिल करता है यदि यह backslash-escaped है।

यद्यपि [link titles] कई लाइनों में फैल सकते हैं, उनमें [blank line] नहीं हो सकती।

एक [inline link](@) एक [link text] से बना है जिसके तुरंत बाद एक बाएं parenthesis `(`, वैकल्पिक [whitespace], एक वैकल्पिक [link destination], एक वैकल्पिक [link title] जो link destination से [whitespace] द्वारा अलग है, वैकल्पिक [whitespace], और एक दाएं parenthesis `)` होता है। लिंक का टेक्स्ट [link text] में शामिल inlines से बना है (enclosing square brackets को छोड़कर)। लिंक का URI link destination से बना है, यदि मौजूद हो तो enclosing `<...>` को छोड़कर, ऊपर वर्णित backslash-escapes के साथ। लिंक का title link title से बना है, इसके enclosing delimiters को छोड़कर, ऊपर वर्णित backslash-escapes के साथ।

यहां एक सरल inline link है:

```example
[link](/uri "title")
.
<p><a href="/uri" title="title">link</a></p>
```

शीर्षक को छोड़ा जा सकता है:

```example
[link](/uri)
.
<p><a href="/uri">link</a></p>
```

शीर्षक और destination दोनों को छोड़ा जा सकता है:

```example
[link]()
.
<p><a href="">link</a></p>
```

```example
[link](<>)
.
<p><a href="">link</a></p>
```

destination में केवल तभी spaces हो सकते हैं यदि यह pointy brackets में enclosed है:

```example
[link](/my uri)
.
<p>[link](/my uri)</p>
```

```example
[link](</my uri>)
.
<p><a href="/my%20uri">link</a></p>
```

destination में line breaks नहीं हो सकते, भले ही pointy brackets में enclosed हो:

```example
[link](foo
bar)
.
<p>[link](foo
bar)</p>
```

```example
[link](<foo
bar>)
.
<p>[link](<foo
bar>)</p>
```

destination में `)` हो सकता है यदि यह pointy brackets में enclosed है:

```example
[a](<b)c>)
.
<p><a href="b)c">a</a></p>
```

लिंक्स को enclose करने वाले pointy brackets unescaped होने चाहिए:

```example
[link](<foo\>)
.
<p>[link](&lt;foo&gt;)</p>
```

ये लिंक्स नहीं हैं, क्योंकि शुरुआती pointy bracket ठीक से मेल नहीं खाता:

```example
[a](<b)c
[a](<b)c>
[a](<b>c)
.
<p>[a](&lt;b)c
[a](&lt;b)c&gt;
[a](<b>c)</p>
```

लिंक destination के अंदर Parentheses को escaped किया जा सकता है:

```example
[link](\(foo\))
.
<p><a href="(foo)">link</a></p>
```

बिना escape के किसी भी संख्या में parentheses की अनुमति है, जब तक वे संतुलित हैं:

```example
[link](foo(and(bar)))
.
<p><a href="foo(and(bar))">link</a></p>
```

हालांकि, यदि आपके पास असंतुलित parentheses हैं, तो आपको escape करने या `<...>` form का उपयोग करने की आवश्यकता है:

```example
[link](foo\(and\(bar\))
.
<p><a href="foo(and(bar)">link</a></p>
```

```example
[link](<foo(and(bar)>)
.
<p><a href="foo(and(bar)">link</a></p>
```

Parentheses और अन्य प्रतीकों को भी escaped किया जा सकता है, जैसा कि Markdown में सामान्य है:

```example
[link](foo\)\:)
.
<p><a href="foo):">link</a></p>
```

एक लिंक में fragment identifiers और queries हो सकते हैं:

```example
[link](#fragment)

[link](http://example.com#fragment)

[link](http://example.com?foo=3#frag)
.
<p><a href="#fragment">link</a></p>
<p><a href="http://example.com#fragment">link</a></p>
<p><a href="http://example.com?foo=3#frag">link</a></p>
```

ध्यान दें कि non-escapable वर्ण से पहले backslash केवल backslash है:

```example
[link](foo\bar)
.
<p><a href="foo%5Cbar">link</a></p>
```

URL-escaping को destination के अंदर अकेला छोड़ दिया जाना चाहिए, क्योंकि सभी URL-escaped वर्ण भी मान्य URL वर्ण हैं। destination में Entity और numerical character references को सामान्य रूप से संबंधित Unicode code points में पार्स किया जाएगा। HTML के रूप में लिखे जाने पर इन्हें वैकल्पिक रूप से URL-escaped किया जा सकता है, लेकिन यह spec HTML या अन्य फ़ॉर्मेट में URLs को रेंडर करने के लिए किसी विशेष नीति को लागू नहीं करता है। Renderers आउटपुट में URLs को escape या normalize करने के बारे में अलग निर्णय ले सकते हैं।

```example
[link](foo%20b&auml;)
.
<p><a href="foo%20b%C3%A4">link</a></p>
```

ध्यान दें कि, क्योंकि titles को अक्सर destinations के रूप में पार्स किया जा सकता है, यदि आप destination को छोड़ने और title को रखने का प्रयास करते हैं, तो आपको अप्रत्याशित परिणाम मिलेंगे:

```example
[link]("title")
.
<p><a href="%22title%22">link</a></p>
```

Titles single quotes, double quotes, या parentheses में हो सकते हैं:

```example
[link](/url "title")
[link](/url 'title')
[link](/url (title))
.
<p><a href="/url" title="title">link</a>
<a href="/url" title="title">link</a>
<a href="/url" title="title">link</a></p>
```

Backslash escapes और entity और numeric character references का उपयोग titles में किया जा सकता है:

```example
[link](/url "title \"&quot;")
.
<p><a href="/url" title="title &quot;&quot;">link</a></p>
```

Titles को लिंक से [whitespace] का उपयोग करके अलग किया जाना चाहिए। अन्य [Unicode whitespace] जैसे non-breaking space काम नहीं करता।

```example
[link](/url "title")
.
<p><a href="/url%C2%A0%22title%22">link</a></p>
```

बिना escape के Nested balanced quotes की अनुमति नहीं है:

```example
[link](/url "title "and" title")
.
<p>[link](/url &quot;title &quot;and&quot; title&quot;)</p>
```

लेकिन एक अलग quote type का उपयोग करके इसके आसपास काम करना आसान है:

```example
[link](/url 'title "and" title')
.
<p><a href="/url" title="title &quot;and&quot; title">link</a></p>
```

(नोट: `Markdown.pl` ने double-quoted title के अंदर double quotes की अनुमति दी, और इसके test suite में इसे demonstrate करने वाला एक test शामिल था। लेकिन इसके लाने वाली अतिरिक्त जटिलता के लिए एक अच्छा तर्क देखना कठिन है, क्योंकि पहले से ही कई तरीके हैं---backslash escaping, entity और numeric character references, या enclosing title के लिए एक अलग quote type का उपयोग---double quotes युक्त titles लिखने के लिए। `Markdown.pl` के titles की हैंडलिंग में कई अन्य अजीब सुविधाएं हैं। उदाहरण के लिए, यह inline links में single-quoted titles की अनुमति देता है, लेकिन reference links में नहीं। और, reference links में लेकिन inline links में नहीं, यह title को `"` से शुरू होने और `)` से समाप्त होने की अनुमति देता है। `Markdown.pl` 1.0.1 तो बिना closing quotation mark के titles की भी अनुमति देता है, हालांकि 1.0.2b8 नहीं देता। यह एक सरल, तर्कसंगत नियम अपनाना प्रीफर करने योग्य लगता है जो inline links और link reference definitions में समान तरीके से काम करता है।)

destination और title के आसपास [Whitespace] की अनुमति है:

```example
[link](   /uri
  "title"  )
.
<p><a href="/uri" title="title">link</a></p>
```

लेकिन लिंक टेक्स्ट और निम्नलिखित parenthesis के बीच इसकी अनुमति नहीं है:

```example
[link] (/uri)
.
<p>[link] (/uri)</p>
```

लिंक टेक्स्ट में संतुलित brackets हो सकते हैं, लेकिन असंतुलित नहीं, जब तक कि वे escaped न हों:

```example
[link [foo [bar]]](/uri)
.
<p><a href="/uri">link [foo [bar]]</a></p>
```

```example
[link] bar](/uri)
.
<p>[link] bar](/uri)</p>
```

```example
[link [bar](/uri)
.
<p>[link <a href="/uri">bar</a></p>
```

```example
[link \[bar](/uri)
.
<p><a href="/uri">link [bar</a></p>
```

लिंक टेक्स्ट में इनलाइन सामग्री हो सकती है:

```example
[link *foo **bar** `#`*](/uri)
.
<p><a href="/uri">link <em>foo <strong>bar</strong> <code>#</code></em></a></p>
```

```example
[![moon](moon.jpg)](/uri)
.
<p><a href="/uri"><img src="moon.jpg" alt="moon" /></a></p>
```

हालांकि, किसी भी स्तर की nesting पर, लिंक्स में अन्य लिंक्स नहीं हो सकते।

```example
[foo [bar](/uri)](/uri)
.
<p>[foo <a href="/uri">bar</a>](/uri)</p>
```

```example
[foo *[bar [baz](/uri)](/uri)*](/uri)
.
<p>[foo <em>[bar <a href="/uri">baz</a>](/uri)</em>](/uri)</p>
```

```example
![[[foo](uri1)](uri2)](uri3)
.
<p><img src="uri3" alt="[foo](uri2)" /></p>
```

ये मामले emphasis grouping पर link text grouping की प्राथमिकता को illustrate करते हैं:

```example
*[foo*](/uri)
.
<p>*<a href="/uri">foo*</a></p>
```

```example
[foo *bar](baz*)
.
<p><a href="baz*">foo *bar</a></p>
```

ध्यान दें कि brackets जो लिंक्स का हिस्सा _नहीं_ हैं, प्राथमिकता नहीं लेते:

```example
*foo [bar* baz]
.
<p><em>foo [bar</em> baz]</p>
```

ये मामले link grouping पर HTML tags, code spans, और autolinks की प्राथमिकता को illustrate करते हैं:

```example
[foo <bar attr="](baz)">
.
<p>[foo <bar attr="](baz)"></p>
```

```example
[foo`](/uri)`
.
<p>[foo<code>](/uri)</code></p>
```

```example
[foo<http://example.com/?search=](uri)>
.
<p>[foo<a href="http://example.com/?search=%5D(uri)">http://example.com/?search=](uri)</a></p>
```

तीन प्रकार के [reference link](@)s हैं: [full](#full-reference-link), [collapsed](#collapsed-reference-link), और [shortcut](#shortcut-reference-link)।

एक [full reference link](@) एक [link text] से बना है जिसके तुरंत बाद एक [link label] होता है जो दस्तावेज़ में कहीं और [link reference definition] से [matches] होता है।

एक [link label](@) एक बाएं bracket (`[`) से शुरू होता है और पहले दाएं bracket (`]`) के साथ समाप्त होता है जो backslash-escaped नहीं है। इन brackets के बीच कम से कम एक [non-whitespace character] होना चाहिए। [link labels] के शुरुआती और समापन square brackets के अंदर Unescaped square bracket वर्णों की अनुमति नहीं है। link label में square brackets के अंदर अधिकतम 999 वर्ण हो सकते हैं।

एक label [matches](@) दूसरे को केवल तभी यदि उनके normalized forms समान हों। label को normalize करने के लिए, शुरुआती और समापन brackets को हटा दें, _Unicode case fold_ करें, अग्रणी और अनुगामी [whitespace] को strip करें और लगातार आंतरिक [whitespace] को single space में collapse करें। यदि कई मिलती-जुलती reference link definitions हैं, तो दस्तावेज़ में पहले आने वाली का उपयोग किया जाता है। (ऐसे मामलों में एक warning emit करना वांछनीय है।)

पहले link label की सामग्री को inlines के रूप में पार्स किया जाता है, जिसे लिंक के टेक्स्ट के रूप में उपयोग किया जाता है। लिंक का URI और title मिलती-जुलती [link reference definition] द्वारा प्रदान किए जाते हैं।

यहां एक सरल उदाहरण है:

```example
[foo][bar]

[bar]: /url "title"
.
<p><a href="/url" title="title">foo</a></p>
```

[link text] के लिए नियम [inline links] के समान हैं। इस प्रकार:

लिंक टेक्स्ट में संतुलित brackets हो सकते हैं, लेकिन असंतुलित नहीं, जब तक कि वे escaped न हों:

```example
[link [foo [bar]]][ref]

[ref]: /uri
.
<p><a href="/uri">link [foo [bar]]</a></p>
```

```example
[link \[bar][ref]

[ref]: /uri
.
<p><a href="/uri">link [bar</a></p>
```

लिंक टेक्स्ट में इनलाइन सामग्री हो सकती है:

```example
[link *foo **bar** `#`*][ref]

[ref]: /uri
.
<p><a href="/uri">link <em>foo <strong>bar</strong> <code>#</code></em></a></p>
```

```example
[![moon](moon.jpg)][ref]

[ref]: /uri
.
<p><a href="/uri"><img src="moon.jpg" alt="moon" /></a></p>
```

हालांकि, किसी भी स्तर की nesting पर, लिंक्स में अन्य लिंक्स नहीं हो सकते।

```example
[foo [bar](/uri)][ref]

[ref]: /uri
.
<p>[foo <a href="/uri">bar</a>]<a href="/uri">ref</a></p>
```

```example
[foo *bar [baz][ref]*][ref]

[ref]: /uri
.
<p>[foo <em>bar <a href="/uri">baz</a></em>]<a href="/uri">ref</a></p>
```

(ऊपर के उदाहरणों में, हमारे पास एक [full reference link] के बजाय दो [shortcut reference links] हैं।)

निम्नलिखित मामले emphasis grouping पर link text grouping की प्राथमिकता को illustrate करते हैं:

```example
*[foo*][ref]

[ref]: /uri
.
<p>*<a href="/uri">foo*</a></p>
```

```example
[foo *bar][ref]

[ref]: /uri
.
<p><a href="/uri">foo *bar</a></p>
```

ये मामले link grouping पर HTML tags, code spans, और autolinks की प्राथमिकता को illustrate करते हैं:

```example
[foo <bar attr="][ref]">

[ref]: /uri
.
<p>[foo <bar attr="][ref]"></p>
```

```example
[foo`][ref]`

[ref]: /uri
.
<p>[foo<code>][ref]</code></p>
```

```example
[foo<http://example.com/?search=][ref]>

[ref]: /uri
.
<p>[foo<a href="http://example.com/?search=%5D%5Bref%5D">http://example.com/?search=][ref]</a></p>
```

मिलान case-insensitive है:

```example
[foo][BaR]

[bar]: /url "title"
.
<p><a href="/url" title="title">foo</a></p>
```

Unicode case fold का उपयोग किया जाता है:

```example
[Толпой][Толпой] is a Russian word.

[ТОЛПОЙ]: /url
.
<p><a href="/url">Толпой</a> is a Russian word.</p>
```

मिलान निर्धारित करने के उद्देश्यों के लिए लगातार आंतरिक [whitespace] को एक space के रूप में माना जाता है:

```example
[Foo
  bar]: /url

[Baz][Foo bar]
.
<p><a href="/url">Baz</a></p>
```

[link text] और [link label] के बीच कोई [whitespace] की अनुमति नहीं है:

```example
[foo] [bar]

[bar]: /url "title"
.
<p>[foo] <a href="/url" title="title">bar</a></p>
```

```example
[foo]
[bar]

[bar]: /url "title"
.
<p>[foo]
<a href="/url" title="title">bar</a></p>
```

यह John Gruber के मूल Markdown सिंटैक्स विवरण से एक प्रस्थान है, जो स्पष्ट रूप से लिंक टेक्स्ट और link label के बीच whitespace की अनुमति देता है। यह reference links को [inline links] के साथ लाइन में लाता है, जो (मूल Markdown और इस spec दोनों के अनुसार) लिंक टेक्स्ट के बाद whitespace नहीं हो सकता। अधिक महत्वपूर्ण रूप से, यह लगातार [shortcut reference links] के अनजाने में capture को रोकता है। यदि लिंक टेक्स्ट और link label के बीच whitespace की अनुमति है, तो निम्नलिखित में हमारे पास एक single reference link होगा, दो shortcut reference links नहीं, जैसा कि intended है:

```markdown
[foo]
[bar]

[foo]: /url1
[bar]: /url2
```

(नोट कि [shortcut reference links] को Gruber ने स्वयं `Markdown.pl` के beta संस्करण में पेश किया था, लेकिन आधिकारिक सिंटैक्स विवरण में कभी शामिल नहीं किया गया। shortcut reference links के बिना, लिंक टेक्स्ट और link label के बीच space की अनुमति देना हानिरहित है; लेकिन एक बार shortcut references पेश किए जाने पर, इसकी अनुमति देना बहुत खतरनाक है, क्योंकि यह अक्सर अनपेक्षित परिणामों की ओर ले जाता है।)

जब कई मिलती-जुलती [link reference definitions] हैं, तो पहली का उपयोग किया जाता है:

```example
[foo]: /url1

[foo]: /url2

[bar][foo]
.
<p><a href="/url1">bar</a></p>
```

ध्यान दें कि मिलान normalized strings पर किया जाता है, पार्स की गई इनलाइन सामग्री पर नहीं। इसलिए निम्नलिखित मेल नहीं खाता, भले ही labels समतुल्य इनलाइन सामग्री को परिभाषित करते हैं:

```example
[bar][foo\!]

[foo!]: /url
.
<p>[bar][foo!]</p>
```

[Link labels] में brackets नहीं हो सकते, जब तक कि वे backslash-escaped न हों:

```example
[foo][ref[]

[ref[]: /uri
.
<p>[foo][ref[]</p>
<p>[ref[]: /uri</p>
```

```example
[foo][ref[bar]]

[ref[bar]]: /uri
.
<p>[foo][ref[bar]]</p>
<p>[ref[bar]]: /uri</p>
```

```example
[[[foo]]]

[[[foo]]]: /url
.
<p>[[[foo]]]</p>
<p>[[[foo]]]: /url</p>
```

```example
[foo][ref\[]

[ref\[]: /uri
.
<p><a href="/uri">foo</a></p>
```

Note that in this example `]` is not backslash-escaped:

```example
[bar\\]: /uri

[bar\\]
.
<p><a href="/uri">bar\</a></p>
```

एक [link label] में कम से कम एक [non-whitespace character] होना चाहिए:

```example
[]

[]: /uri
.
<p>[]</p>
<p>[]: /uri</p>
```

```example
[
 ]

[
 ]: /uri
.
<p>[
]</p>
<p>[
]: /uri</p>
```

एक [collapsed reference link](@) एक [link label] से बना है जो दस्तावेज़ में कहीं और [link reference definition] से [matches] होता है, जिसके बाद स्ट्रिंग `[]` होती है। पहले link label की सामग्री को inlines के रूप में पार्स किया जाता है, जिसे लिंक के टेक्स्ट के रूप में उपयोग किया जाता है। लिंक का URI और title मिलती-जुलती reference link definition द्वारा प्रदान किए जाते हैं। इस प्रकार, `[foo][]` `[foo][foo]` के समतुल्य है।

```example
[foo][]

[foo]: /url "title"
.
<p><a href="/url" title="title">foo</a></p>
```

```example
[*foo* bar][]

[*foo* bar]: /url "title"
.
<p><a href="/url" title="title"><em>foo</em> bar</a></p>
```

link labels case-insensitive हैं:

```example
[Foo][]

[foo]: /url "title"
.
<p><a href="/url" title="title">Foo</a></p>
```

full reference links की तरह, brackets के दो सेटों के बीच [whitespace] की अनुमति नहीं है:

```example
[foo]
[]

[foo]: /url "title"
.
<p><a href="/url" title="title">foo</a>
[]</p>
```

एक [shortcut reference link](@) एक [link label] से बना है जो दस्तावेज़ में कहीं और [link reference definition] से [matches] होता है और इसके बाद `[]` या link label नहीं होता। पहले link label की सामग्री को inlines के रूप में पार्स किया जाता है, जिसे लिंक के टेक्स्ट के रूप में उपयोग किया जाता है। लिंक का URI और title मिलती-जुलती link reference definition द्वारा प्रदान किए जाते हैं। इस प्रकार, `[foo]` `[foo][]` के समतुल्य है।

```example
[foo]

[foo]: /url "title"
.
<p><a href="/url" title="title">foo</a></p>
```

```example
[*foo* bar]

[*foo* bar]: /url "title"
.
<p><a href="/url" title="title"><em>foo</em> bar</a></p>
```

```example
[[*foo* bar]]

[*foo* bar]: /url "title"
.
<p>[<a href="/url" title="title"><em>foo</em> bar</a>]</p>
```

```example
[[bar [foo]

[foo]: /url
.
<p>[[bar <a href="/url">foo</a></p>
```

link labels case-insensitive हैं:

```example
[Foo]

[foo]: /url "title"
.
<p><a href="/url" title="title">Foo</a></p>
```

लिंक टेक्स्ट के बाद space को संरक्षित किया जाना चाहिए:

```example
[foo] bar

[foo]: /url
.
<p><a href="/url">foo</a> bar</p>
```

यदि आप केवल bracketed टेक्स्ट चाहते हैं, तो आप लिंक्स से बचने के लिए शुरुआती bracket को backslash-escape कर सकते हैं:

```example
\[foo]

[foo]: /url "title"
.
<p>[foo]</p>
```

ध्यान दें कि यह लिंक है, क्योंकि link label पहले निम्नलिखित closing bracket के साथ समाप्त होता है:

```example
[foo*]: /url

*[foo*]
.
<p>*<a href="/url">foo*</a></p>
```

Full और compact references shortcut references पर प्राथमिकता लेते हैं:

```example
[foo][bar]

[foo]: /url1
[bar]: /url2
.
<p><a href="/url2">foo</a></p>
```

```example
[foo][]

[foo]: /url1
.
<p><a href="/url1">foo</a></p>
```

Inline links भी प्राथमिकता लेते हैं:

```example
[foo]()

[foo]: /url1
.
<p><a href="">foo</a></p>
```

```example
[foo](not a link)

[foo]: /url1
.
<p><a href="/url1">foo</a>(not a link)</p>
```

निम्नलिखित मामले में `[bar][baz]` को reference के रूप में पार्स किया जाता है, `[foo]` को सामान्य टेक्स्ट के रूप में:

```example
[foo][bar][baz]

[baz]: /url
.
<p>[foo]<a href="/url">bar</a></p>
```

यहां, हालांकि, `[foo][bar]` को reference के रूप में पार्स किया जाता है, क्योंकि `[bar]` परिभाषित है:

```example
[foo][bar][baz]

[baz]: /url1
[bar]: /url2
.
<p><a href="/url2">foo</a><a href="/url1">baz</a></p>
```

यहां `[foo]` को shortcut reference के रूप में पार्स नहीं किया जाता, क्योंकि इसके बाद link label है (भले ही `[bar]` परिभाषित नहीं है):

```example
[foo][bar][baz]

[baz]: /url1
[foo]: /url2
.
<p>[foo]<a href="/url1">bar</a></p>
```

## छवियाँ

छवियों के लिए सिंटैक्स लिंक्स के लिए सिंटैक्स की तरह है, एक अंतर के साथ। [link text] के बजाय, हमारे पास [image description](@) है। इसके लिए नियम [link text] के समान हैं, सिवाय इसके कि (a) image description `[` के बजाय `![` से शुरू होता है, और (b) image description में लिंक्स हो सकते हैं। image description में इसकी सामग्री के रूप में इनलाइन एलिमेंट्स होते हैं। जब छवि को HTML में रेंडर किया जाता है, तो इसे मानक रूप से छवि के `alt` एट्रिब्यूट के रूप में उपयोग किया जाता है।

```example
![foo](/url "title")
.
<p><img src="/url" alt="foo" title="title" /></p>
```

```example
![foo *bar*]

[foo *bar*]: train.jpg "train & tracks"
.
<p><img src="train.jpg" alt="foo bar" title="train &amp; tracks" /></p>
```

```example
![foo ![bar](/url)](/url2)
.
<p><img src="/url2" alt="foo bar" /></p>
```

```example
![foo [bar](/url)](/url2)
.
<p><img src="/url2" alt="foo bar" /></p>
```

यद्यपि यह spec पार्सिंग से संबंधित है, रेंडरिंग से नहीं, यह अनुशंसा की जाती है कि HTML में रेंडर करते समय, केवल [image description] की plain string सामग्री का उपयोग किया जाए। ध्यान दें कि उपरोक्त उदाहरण में, alt attribute का मान `foo bar` है, `foo [bar](/url)` या `foo <a href="/url">bar</a>` नहीं। केवल plain string सामग्री को बिना formatting के रेंडर किया जाता है।

```example
![foo *bar*][]

[foo *bar*]: train.jpg "train & tracks"
.
<p><img src="train.jpg" alt="foo bar" title="train &amp; tracks" /></p>
```

```example
![foo *bar*][foobar]

[FOOBAR]: train.jpg "train & tracks"
.
<p><img src="train.jpg" alt="foo bar" title="train &amp; tracks" /></p>
```

```example
![foo](train.jpg)
.
<p><img src="train.jpg" alt="foo" /></p>
```

```example
My ![foo bar](/path/to/train.jpg  "title"   )
.
<p>My <img src="/path/to/train.jpg" alt="foo bar" title="title" /></p>
```

```example
![foo](<url>)
.
<p><img src="url" alt="foo" /></p>
```

```example
![](/url)
.
<p><img src="/url" alt="" /></p>
```

Reference-style:

```example
![foo][bar]

[bar]: /url
.
<p><img src="/url" alt="foo" /></p>
```

```example
![foo][bar]

[BAR]: /url
.
<p><img src="/url" alt="foo" /></p>
```

Collapsed:

```example
![foo][]

[foo]: /url "title"
.
<p><img src="/url" alt="foo" title="title" /></p>
```

```example
![*foo* bar][]

[*foo* bar]: /url "title"
.
<p><img src="/url" alt="foo bar" title="title" /></p>
```

labels case-insensitive हैं:

```example
![Foo][]

[foo]: /url "title"
.
<p><img src="/url" alt="Foo" title="title" /></p>
```

reference links की तरह, brackets के दो सेटों के बीच [whitespace] की अनुमति नहीं है:

```example
![foo]
[]

[foo]: /url "title"
.
<p><img src="/url" alt="foo" title="title" />
[]</p>
```

Shortcut:

```example
![foo]

[foo]: /url "title"
.
<p><img src="/url" alt="foo" title="title" /></p>
```

```example
![*foo* bar]

[*foo* bar]: /url "title"
.
<p><img src="/url" alt="foo bar" title="title" /></p>
```

ध्यान दें कि link labels में unescaped brackets नहीं हो सकते:

```example
![[foo]]

[[foo]]: /url "title"
.
<p>![[foo]]</p>
<p>[[foo]]: /url &quot;title&quot;</p>
```

link labels case-insensitive हैं:

```example
![Foo]

[foo]: /url "title"
.
<p><img src="/url" alt="Foo" title="title" /></p>
```

यदि आप केवल bracketed टेक्स्ट के बाद शाब्दिक `!` चाहते हैं, तो आप शुरुआती `[` को backslash-escape कर सकते हैं:

```example
!\[foo]

[foo]: /url "title"
.
<p>![foo]</p>
```

यदि आप शाब्दिक `!` के बाद लिंक चाहते हैं, तो `!` को backslash-escape करें:

```example
\![foo]

[foo]: /url "title"
.
<p>!<a href="/url" title="title">foo</a></p>
```

## ऑटोलिंक्स

[Autolink](@)s `<` और `>` के अंदर absolute URIs और email addresses हैं। उन्हें लिंक्स के रूप में पार्स किया जाता है, URL या email address लिंक label के रूप में।

एक [URI autolink](@) में `<` होता है, जिसके बाद [absolute URI] होता है जिसके बाद `>` होता है। इसे URI के लिंक के रूप में पार्स किया जाता है, URI लिंक के label के रूप में।

एक [absolute URI](@), इन उद्देश्यों के लिए, एक [scheme] से बना है जिसके बाद colon (`:`) होता है जिसके बाद शून्य या अधिक वर्ण होते हैं जो ASCII [whitespace] और control characters, `<`, और `>` के अलावा होते हैं। यदि URI में ये वर्ण शामिल हैं, तो उन्हें percent-encoded होना चाहिए (जैसे space के लिए `%20`)।

इस spec के उद्देश्यों के लिए, [scheme](@) 2--32 वर्णों का कोई भी अनुक्रम है जो ASCII अक्षर से शुरू होता है और ASCII अक्षरों, अंकों, या प्रतीकों plus ("+"), period ("."), या hyphen ("-") के किसी भी संयोजन द्वारा अनुसरण किया जाता है।

यहां कुछ मान्य autolinks हैं:

```example
<http://foo.bar.baz>
.
<p><a href="http://foo.bar.baz">http://foo.bar.baz</a></p>
```

```example
<http://foo.bar.baz/test?q=hello&id=22&boolean>
.
<p><a href="http://foo.bar.baz/test?q=hello&amp;id=22&amp;boolean">http://foo.bar.baz/test?q=hello&amp;id=22&amp;boolean</a></p>
```

```example
<irc://foo.bar:2233/baz>
.
<p><a href="irc://foo.bar:2233/baz">irc://foo.bar:2233/baz</a></p>
```

Uppercase भी ठीक है:

```example
<MAILTO:FOO@BAR.BAZ>
.
<p><a href="MAILTO:FOO@BAR.BAZ">MAILTO:FOO@BAR.BAZ</a></p>
```

ध्यान दें कि कई strings जो इस spec के उद्देश्यों के लिए [absolute URIs] के रूप में गिनी जाती हैं, मान्य URIs नहीं हैं, क्योंकि उनकी schemes पंजीकृत नहीं हैं या उनके सिंटैक्स के साथ अन्य समस्याओं के कारण:

```example
<a+b+c:d>
.
<p><a href="a+b+c:d">a+b+c:d</a></p>
```

```example
<made-up-scheme://foo,bar>
.
<p><a href="made-up-scheme://foo,bar">made-up-scheme://foo,bar</a></p>
```

```example
<http://../>
.
<p><a href="http://../">http://../</a></p>
```

```example
<localhost:5001/foo>
.
<p><a href="localhost:5001/foo">localhost:5001/foo</a></p>
```

Autolinks में Spaces की अनुमति नहीं है:

```example
<http://foo.bar/baz bim>
.
<p>&lt;http://foo.bar/baz bim&gt;</p>
```

Backslash-escapes autolinks के अंदर काम नहीं करते:

```example
<http://example.com/\[\>
.
<p><a href="http://example.com/%5C%5B%5C">http://example.com/\[\</a></p>
```

एक [email autolink](@) में `<` होता है, जिसके बाद [email address] होता है, जिसके बाद `>` होता है। लिंक का label email address है, और URL `mailto:` है जिसके बाद email address है।

एक [email address](@), इन उद्देश्यों के लिए, कुछ भी है जो [HTML5 spec से non-normative regex](<https://html.spec.whatwg.org/multipage/forms.html#e-mail-state-(type=email)>) से मेल खाता है:

    /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?
    (?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/

email autolinks के उदाहरण:

```example
<foo@bar.example.com>
.
<p><a href="mailto:foo@bar.example.com">foo@bar.example.com</a></p>
```

```example
<foo+special@Bar.baz-bar0.com>
.
<p><a href="mailto:foo+special@Bar.baz-bar0.com">foo+special@Bar.baz-bar0.com</a></p>
```

Backslash-escapes email autolinks के अंदर काम नहीं करते:

```example
<foo\+@bar.example.com>
.
<p>&lt;foo+@bar.example.com&gt;</p>
```

ये autolinks नहीं हैं:

```example
<>
.
<p>&lt;&gt;</p>
```

```example
< http://foo.bar >
.
<p>&lt; http://foo.bar &gt;</p>
```

```example
<m:abc>
.
<p>&lt;m:abc&gt;</p>
```

```example
<foo.bar.baz>
.
<p>&lt;foo.bar.baz&gt;</p>
```

```example
http://example.com
.
<p>http://example.com</p>
```

```example
foo@bar.example.com
.
<p>foo@bar.example.com</p>
```

<div class="extension">

## ऑटोलिंक्स (एक्सटेंशन)

GFM `autolink` एक्सटेंशन को सक्षम करता है, जहां autolinks को अधिक संख्या में स्थितियों में पहचाना जाएगा।

[Autolink]s को उन्हें delimit करने के लिए `<` और `>` के उपयोग की आवश्यकता के बिना भी बनाया जा सकता है, हालांकि उन्हें परिस्थितियों के एक छोटे सेट के तहत पहचाना जाएगा। ऐसे सभी पहचाने गए autolinks केवल लाइन की शुरुआत में, whitespace के बाद, या delimiting वर्णों `*`, `_`, `~`, और `(` में से किसी के बाद आ सकते हैं।

एक [extended www autolink](@) को पहचाना जाएगा जब टेक्स्ट `www.` मिलता है जिसके बाद [valid domain] होता है। एक [valid domain](@) में alphanumeric वर्णों, underscores (`_`) और hyphens (`-`) के segments होते हैं जो periods (`.`) द्वारा अलग होते हैं। कम से कम एक period होना चाहिए, और domain के अंतिम दो segments में कोई underscores नहीं हो सकते।

scheme `http` स्वचालित रूप से डाली जाएगी:

```example autolink
www.commonmark.org
.
<p><a href="http://www.commonmark.org">www.commonmark.org</a></p>
```

[valid domain] के बाद, शून्य या अधिक non-space non-`<` वर्ण अनुसरण कर सकते हैं:

```example autolink
Visit www.commonmark.org/help for more information.
.
<p>Visit <a href="http://www.commonmark.org/help">www.commonmark.org/help</a> for more information.</p>
```

फिर हम [extended autolink path validation](@) को निम्नानुसार लागू करते हैं:

अनुगामी विराम चिह्न (विशेष रूप से, `?`, `!`, `.`, `,`, `:`, `*`, `_`, और `~`) को autolink का हिस्सा नहीं माना जाएगा, हालांकि उन्हें लिंक के आंतरिक में शामिल किया जा सकता है:

```example autolink
Visit www.commonmark.org.

Visit www.commonmark.org/a.b.
.
<p>Visit <a href="http://www.commonmark.org">www.commonmark.org</a>.</p>
<p>Visit <a href="http://www.commonmark.org/a.b">www.commonmark.org/a.b</a>.</p>
```

जब autolink `)` में समाप्त होता है, तो हम parentheses की कुल संख्या के लिए पूरे autolink को स्कैन करते हैं। यदि शुरुआती parentheses की तुलना में समापन parentheses की संख्या अधिक है, तो हम unmatched अनुगामी parentheses को autolink का हिस्सा नहीं मानते, parenthesis के अंदर autolink शामिल करने की सुविधा के लिए:

```example autolink
www.google.com/search?q=Markup+(business)

www.google.com/search?q=Markup+(business)))

(www.google.com/search?q=Markup+(business))

(www.google.com/search?q=Markup+(business)
.
<p><a href="http://www.google.com/search?q=Markup+(business)">www.google.com/search?q=Markup+(business)</a></p>
<p><a href="http://www.google.com/search?q=Markup+(business)">www.google.com/search?q=Markup+(business)</a>))</p>
<p>(<a href="http://www.google.com/search?q=Markup+(business)">www.google.com/search?q=Markup+(business)</a>)</p>
<p>(<a href="http://www.google.com/search?q=Markup+(business)">www.google.com/search?q=Markup+(business)</a></p>
```

यह जांच केवल तभी की जाती है जब लिंक समापन parentheses `)` में समाप्त होता है, इसलिए यदि केवल parentheses autolink के आंतरिक में हैं, तो कोई विशेष नियम लागू नहीं होते:

```example autolink
www.google.com/search?q=(business))+ok
.
<p><a href="http://www.google.com/search?q=(business))+ok">www.google.com/search?q=(business))+ok</a></p>
```

यदि autolink semicolon (`;`) में समाप्त होता है, तो हम जांचते हैं कि क्या यह [entity reference][entity references] जैसा दिखता है; यदि पूर्ववर्ती टेक्स्ट `&` है जिसके बाद एक या अधिक alphanumeric वर्ण हैं। यदि ऐसा है, तो इसे autolink से excluded किया जाता है:

```example autolink
www.google.com/search?q=commonmark&hl=en

www.google.com/search?q=commonmark&hl;
.
<p><a href="http://www.google.com/search?q=commonmark&amp;hl=en">www.google.com/search?q=commonmark&amp;hl=en</a></p>
<p><a href="http://www.google.com/search?q=commonmark">www.google.com/search?q=commonmark</a>&amp;hl;</p>
```

`<` तुरंत autolink को समाप्त कर देता है।

```example autolink
www.commonmark.org/he<lp
.
<p><a href="http://www.commonmark.org/he">www.commonmark.org/he</a>&lt;lp</p>
```

एक [extended url autolink](@) को तब पहचाना जाएगा जब schemes `http://`, `https://`, या `ftp://` में से एक, जिसके बाद [valid domain], फिर [extended autolink path validation] के अनुसार शून्य या अधिक non-space non-`<` वर्ण:

```example autolink
http://commonmark.org

(Visit https://encrypted.google.com/search?q=Markup+(business))

Anonymous FTP is available at ftp://foo.bar.baz.
.
<p><a href="http://commonmark.org">http://commonmark.org</a></p>
<p>(Visit <a href="https://encrypted.google.com/search?q=Markup+(business)">https://encrypted.google.com/search?q=Markup+(business)</a>)</p>
<p>Anonymous FTP is available at <a href="ftp://foo.bar.baz">ftp://foo.bar.baz</a>.</p>
```

एक [extended email autolink](@) को तब पहचाना जाएगा जब किसी भी टेक्स्ट node के भीतर email address को पहचाना जाता है। Email addresses को निम्नलिखित नियमों के अनुसार पहचाना जाता है:

- एक या अधिक वर्ण जो alphanumeric, या `.`, `-`, `_`, या `+` हैं।
- एक `@` प्रतीक।
- एक या अधिक वर्ण जो alphanumeric, या `-` या `_` हैं, periods (`.`) द्वारा अलग किए गए। कम से कम एक period होना चाहिए। अंतिम वर्ण `-` या `_` में से एक नहीं होना चाहिए।

scheme `mailto:` स्वचालित रूप से उत्पन्न लिंक में जोड़ी जाएगी:

```example autolink
foo@bar.baz
.
<p><a href="mailto:foo@bar.baz">foo@bar.baz</a></p>
```

`+` `@` से पहले हो सकता है, लेकिन बाद में नहीं।

```example autolink
hello@mail+xyz.example isn't valid, but hello+xyz@mail.example is.
.
<p>hello@mail+xyz.example isn't valid, but <a href="mailto:hello+xyz@mail.example">hello+xyz@mail.example</a> is.</p>
```

`.`, `-`, और `_` `@` के दोनों तरफ हो सकते हैं, लेकिन केवल `.` email address के अंत में हो सकता है, जिस स्थिति में इसे address का हिस्सा नहीं माना जाएगा:

```example autolink
a.b-c_d@a.b

a.b-c_d@a.b.

a.b-c_d@a.b-

a.b-c_d@a.b_
.
<p><a href="mailto:a.b-c_d@a.b">a.b-c_d@a.b</a></p>
<p><a href="mailto:a.b-c_d@a.b">a.b-c_d@a.b</a>.</p>
<p>a.b-c_d@a.b-</p>
<p>a.b-c_d@a.b_</p>
```

</div>

## Raw HTML

`<` और `>` के बीच टेक्स्ट जो HTML टैग जैसा दिखता है उसे raw HTML टैग के रूप में पार्स किया जाता है और बिना escaping के HTML में रेंडर किया जाएगा। Tag और attribute names वर्तमान HTML टैग्स तक सीमित नहीं हैं, इसलिए custom tags (और यहां तक कि, कहें, DocBook tags) का उपयोग किया जा सकता है।

यहां tags के लिए grammar है:

एक [tag name](@) एक ASCII अक्षर से बना है जिसके बाद शून्य या अधिक ASCII अक्षर, अंक, या hyphens (`-`) होते हैं।

एक [attribute](@) में [whitespace], एक [attribute name], और एक वैकल्पिक [attribute value specification] शामिल हैं।

एक [attribute name](@) एक ASCII अक्षर, `_`, या `:` से बना है, जिसके बाद शून्य या अधिक ASCII अक्षर, अंक, `_`, `.`, `:`, या `-` होते हैं। (नोट: यह ASCII तक प्रतिबंधित XML specification है। HTML5 अधिक lax है।)

एक [attribute value specification](@) में वैकल्पिक [whitespace], एक `=` वर्ण, वैकल्पिक [whitespace], और एक [attribute value] शामिल हैं।

एक [attribute value](@) एक [unquoted attribute value], एक [single-quoted attribute value], या एक [double-quoted attribute value] से बना है।

एक [unquoted attribute value](@) वर्णों की एक nonempty string है जिसमें [whitespace], `"`, `'`, `=`, `<`, `>`, या `` ` `` शामिल नहीं है।

एक [single-quoted attribute value](@) में `'`, शून्य या अधिक वर्ण जिनमें `'` शामिल नहीं है, और एक अंतिम `'` शामिल है।

एक [double-quoted attribute value](@) में `"`, शून्य या अधिक वर्ण जिनमें `"` शामिल नहीं है, और एक अंतिम `"` शामिल है।

एक [open tag](@) में `<` वर्ण, [tag name], शून्य या अधिक [attributes], वैकल्पिक [whitespace], एक वैकल्पिक `/` वर्ण, और `>` वर्ण शामिल हैं।

एक [closing tag](@) में string `</`, एक [tag name], वैकल्पिक [whitespace], और वर्ण `>` शामिल हैं।

एक [HTML comment](@) में `<!-->`, `<!--->`, या `<!--`, वर्णों की एक string जिसमें string `-->` शामिल नहीं है, और `-->` शामिल हैं ([HTML spec](https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state) देखें)।

एक [processing instruction](@) में string `<?`, वर्णों की एक string जिसमें string `?>` शामिल नहीं है, और string `?>` शामिल हैं।

एक [declaration](@) में string `<!`, एक या अधिक uppercase ASCII अक्षरों से बना एक नाम, [whitespace], वर्णों की एक string जिसमें वर्ण `>` शामिल नहीं है, और वर्ण `>` शामिल हैं।

एक [CDATA section](@) में string `<![CDATA[`, वर्णों की एक string जिसमें string `]]>` शामिल नहीं है, और string `]]>` शामिल हैं।

एक [HTML tag](@) में [open tag], [closing tag], [HTML comment], [processing instruction], [declaration], या [CDATA section] शामिल हैं।

यहां कुछ सरल open tags हैं:

```example
<a><bab><c2c>
.
<p><a><bab><c2c></p>
```

खाली एलिमेंट्स:

```example
<a/><b2/>
.
<p><a/><b2/></p>
```

[Whitespace] की अनुमति है:

```example
<a  /><b2
data="foo" >
.
<p><a  /><b2
data="foo" ></p>
```

attributes के साथ:

```example
<a foo="bar" bam = 'baz <em>"</em>'
_boolean zoop:33=zoop:33 />
.
<p><a foo="bar" bam = 'baz <em>"</em>'
_boolean zoop:33=zoop:33 /></p>
```

Custom tag names का उपयोग किया जा सकता है:

```example
Foo <responsive-image src="foo.jpg" />
.
<p>Foo <responsive-image src="foo.jpg" /></p>
```

अवैध tag names, HTML के रूप में पार्स नहीं:

```example
<33> <__>
.
<p>&lt;33&gt; &lt;__&gt;</p>
```

अवैध attribute names:

```example
<a h*#ref="hi">
.
<p>&lt;a h*#ref=&quot;hi&quot;&gt;</p>
```

अवैध attribute values:

```example
<a href="hi'> <a href=hi'>
.
<p>&lt;a href=&quot;hi'&gt; &lt;a href=hi'&gt;</p>
```

अवैध [whitespace]:

```example
< a><
foo><bar/ >
<foo bar=baz
bim!bop />
.
<p>&lt; a&gt;&lt;
foo&gt;&lt;bar/ &gt;
&lt;foo bar=baz
bim!bop /&gt;</p>
```

गुम [whitespace]:

```example
<a href='bar'title=title>
.
<p>&lt;a href='bar'title=title&gt;</p>
```

समापन tags:

```example
</a></foo >
.
<p></a></foo ></p>
```

समापन tag में अवैध attributes:

```example
</a href="foo">
.
<p>&lt;/a href=&quot;foo&quot;&gt;</p>
```

Comments:

```example
foo <!-- this is a --
comment - with hyphens -->
.
<p>foo <!-- this is a --
comment - with hyphens --></p>
```

```example
foo <!--> foo -->

foo <!---> foo -->
.
<p>foo <!--> foo --&gt;</p>
<p>foo <!---> foo --&gt;</p>
```

Processing instructions:

```example
foo <?php echo $a; ?>
.
<p>foo <?php echo $a; ?></p>
```

Declarations:

```example
foo <!ELEMENT br EMPTY>
.
<p>foo <!ELEMENT br EMPTY></p>
```

CDATA sections:

```example
foo <![CDATA[>&<]]>
.
<p>foo <![CDATA[>&<]]></p>
```

HTML attributes में Entity और numeric character references संरक्षित हैं:

```example
foo <a href="&ouml;">
.
<p>foo <a href="&ouml;"></p>
```

HTML attributes में Backslash escapes काम नहीं करते:

```example
foo <a href="\*">
.
<p>foo <a href="\*"></p>
```

```example
<a href="\"">
.
<p>&lt;a href=&quot;&quot;&quot;&gt;</p>
```

<div class="extension">

## अनुमति नहीं दिया गया Raw HTML (एक्सटेंशन)

GFM `tagfilter` एक्सटेंशन को सक्षम करता है, जहां HTML आउटपुट को रेंडर करते समय निम्नलिखित HTML टैग्स को फ़िल्टर किया जाएगा:

- `<title>`
- `<textarea>`
- `<style>`
- `<xmp>`
- `<iframe>`
- `<noembed>`
- `<noframes>`
- `<script>`
- `<plaintext>`

फ़िल्टरिंग अग्रणी `<` को entity `&lt;` से बदलकर की जाती है। इन टैग्स को विशेष रूप से चुना जाता है क्योंकि वे HTML को उनके लिए अद्वितीय तरीके से व्याख्यायित करने का तरीका बदलते हैं (यानी nested HTML को अलग तरीके से व्याख्यायित किया जाता है), और यह आमतौर पर अन्य रेंडर की गई Markdown सामग्री के संदर्भ में अवांछनीय है।

अन्य सभी HTML टैग्स अछूते रहते हैं।

```example tagfilter
<strong> <title> <style> <em>

<blockquote>
  <xmp> is disallowed.  <XMP> is also disallowed.
</blockquote>
.
<p><strong> &lt;title> &lt;style> <em></p>
<blockquote>
  &lt;xmp> is disallowed.  &lt;XMP> is also disallowed.
</blockquote>
```

</div>

## हार्ड लाइन ब्रेक्स

एक line break (code span या HTML tag में नहीं) जो दो या अधिक spaces से पहले है और ब्लॉक के अंत में नहीं होती है, उसे [hard line break](@) के रूप में पार्स किया जाता है (HTML में `<br />` tag के रूप में रेंडर किया जाता है):

```example
foo
baz
.
<p>foo<br />
baz</p>
```

अधिक दृश्यमान विकल्प के लिए, दो spaces के बजाय [line ending] से पहले backslash का उपयोग किया जा सकता है:

```example
foo\
baz
.
<p>foo<br />
baz</p>
```

दो से अधिक spaces का उपयोग किया जा सकता है:

```example
foo
baz
.
<p>foo<br />
baz</p>
```

अगली लाइन की शुरुआत में अग्रणी spaces को नजरअंदाज किया जाता है:

```example
foo
     bar
.
<p>foo<br />
bar</p>
```

```example
foo\
     bar
.
<p>foo<br />
bar</p>
```

Line breaks ज़ोर, लिंक्स, और अन्य कंस्ट्रक्ट्स के अंदर हो सकते हैं जो इनलाइन सामग्री की अनुमति देते हैं:

```example
*foo
bar*
.
<p><em>foo<br />
bar</em></p>
```

```example
*foo\
bar*
.
<p><em>foo<br />
bar</em></p>
```

Line breaks code spans के अंदर नहीं होते

```example
`code
span`
.
<p><code>code   span</code></p>
```

```example
`code\
span`
.
<p><code>code\ span</code></p>
```

या HTML tags:

```example
<a href="foo
bar">
.
<p><a href="foo
bar"></p>
```

```example
<a href="foo\
bar">
.
<p><a href="foo\
bar"></p>
```

Hard line breaks ब्लॉक के भीतर इनलाइन सामग्री को अलग करने के लिए हैं। पैराग्राफ या अन्य ब्लॉक एलिमेंट के अंत में hard line breaks के लिए न तो सिंटैक्स काम करता है:

```example
foo\
.
<p>foo\</p>
```

```example
foo
.
<p>foo</p>
```

```example
### foo\
.
<h3>foo\</h3>
```

```example
### foo
.
<h3>foo</h3>
```

## सॉफ़्ट लाइन ब्रेक्स

एक नियमित line break (code span या HTML tag में नहीं) जो दो या अधिक spaces या backslash से पहले नहीं है, उसे [softbreak](@) के रूप में पार्स किया जाता है। (एक softbreak को HTML में या तो [line ending] या space के रूप में रेंडर किया जा सकता है। ब्राउज़रों में परिणाम समान होगा। यहां के उदाहरणों में, [line ending] का उपयोग किया जाएगा।)

```example
foo
baz
.
<p>foo
baz</p>
```

लाइन के अंत और अगली लाइन की शुरुआत में spaces को हटा दिया जाता है:

```example
foo
 baz
.
<p>foo
baz</p>
```

एक अनुरूप पार्सर HTML में soft line break को या तो line break या space के रूप में रेंडर कर सकता है।

एक renderer soft line breaks को hard line breaks के रूप में रेंडर करने का विकल्प भी प्रदान कर सकता है।

## टेक्स्ट सामग्री

उपरोक्त नियमों द्वारा व्याख्या नहीं दिए गए कोई भी वर्ण सादे textual सामग्री के रूप में पार्स किए जाएंगे।

```example
hello $.;'there
.
<p>hello $.;'there</p>
```

```example
Foo χρῆν
.
<p>Foo χρῆν</p>
```

आंतरिक spaces को verbatim संरक्षित किया जाता है:

```example
Multiple     spaces
.
<p>Multiple     spaces</p>
```

<!-- END TESTS -->

# परिशिष्ट: एक पार्सिंग रणनीति

इस परिशिष्ट में हम CommonMark संदर्भ कार्यान्वयनों में उपयोग की जाने वाली पार्सिंग रणनीति की कुछ सुविधाओं का वर्णन करते हैं।

## अवलोकन

पार्सिंग के दो चरण हैं:

1. पहले चरण में, इनपुट की लाइनों को consumed किया जाता है और दस्तावेज़ की ब्लॉक संरचना---पैराग्राफ, ब्लॉक कोट्स, सूची आइटम्स, इत्यादि में इसका विभाजन---बनाया जाता है। टेक्स्ट को इन ब्लॉक्स को सौंपा जाता है लेकिन पार्स नहीं किया जाता। Link reference definitions को पार्स किया जाता है और लिंक्स का एक मैप बनाया जाता है।

2. दूसरे चरण में, पैराग्राफ और हेडिंग्स की raw टेक्स्ट सामग्री को Markdown inline elements (strings, code spans, links, emphasis, इत्यादि) के अनुक्रमों में पार्स किया जाता है, चरण 1 में बनाए गए link references के मैप का उपयोग करके।

प्रोसेसिंग के प्रत्येक बिंदु पर, दस्तावेज़ को **blocks** के एक tree के रूप में दर्शाया जाता है। tree का root एक `document` block है। `document` में किसी भी संख्या में अन्य blocks **children** के रूप में हो सकते हैं। ये children, बदले में, अन्य blocks को children के रूप में रख सकते हैं। block का अंतिम child सामान्य रूप से **open** माना जाता है, जिसका अर्थ है कि इनपुट की बाद की लाइनें इसकी सामग्री को बदल सकती हैं। (Blocks जो open नहीं हैं वे **closed** हैं।) यहां, उदाहरण के लिए, एक संभावित document tree है, open blocks तीरों द्वारा चिह्नित:

```tree
-> document
  -> block_quote
       paragraph
         "Lorem ipsum dolor\nsit amet."
    -> list (type=bullet tight=true bullet_char=-)
         list_item
           paragraph
             "Qui *quodsi iracundia*"
      -> list_item
        -> paragraph
             "aliquando id"
```

## चरण 1: ब्लॉक संरचना

प्रोसेस की गई प्रत्येक लाइन का इस tree पर प्रभाव पड़ता है। लाइन का विश्लेषण किया जाता है और, इसकी सामग्री के आधार पर, दस्तावेज़ को निम्नलिखित में से एक या अधिक तरीकों से बदला जा सकता है:

1. एक या अधिक open blocks को closed किया जा सकता है।
2. अंतिम open block के children के रूप में एक या अधिक नए blocks बनाए जा सकते हैं।
3. tree पर शेष अंतिम (सबसे गहरे) open block में टेक्स्ट जोड़ा जा सकता है।

एक बार जब इस तरह से लाइन को tree में शामिल कर लिया गया है, तो इसे discard किया जा सकता है, इसलिए इनपुट को stream में पढ़ा जा सकता है।

प्रत्येक लाइन के लिए, हम इस प्रक्रिया का पालन करते हैं:

1. पहले हम open blocks के माध्यम से iterate करते हैं, root document से शुरू करते हैं, और अंतिम children के माध्यम से अंतिम open block तक उतरते हैं। प्रत्येक block एक शर्त लगाता है जिसे लाइन को पूरा करना होगा यदि block open रहना है। उदाहरण के लिए, block quote को `>` वर्ण की आवश्यकता है। paragraph को non-blank line की आवश्यकता है। इस चरण में हम सभी या कुछ open blocks से मेल खा सकते हैं। लेकिन हम अभी तक unmatched blocks को close नहीं कर सकते, क्योंकि हमारे पास [lazy continuation line] हो सकती है।

2. अगला, मौजूदा blocks के लिए continuation markers को consume करने के बाद, हम नए block starts देखते हैं (जैसे block quote के लिए `>`)। यदि हमें नया block start मिलता है, तो हम अंतिम matched block के child के रूप में नया block बनाने से पहले step 1 में unmatched किसी भी blocks को close करते हैं।

3. अंत में, हम लाइन के शेष भाग को देखते हैं (block markers जैसे `>`, list markers, और इंडेंटेशन के consumed होने के बाद)। यह टेक्स्ट है जिसे अंतिम open block (paragraph, code block, heading, या raw HTML) में शामिल किया जा सकता है।

Setext headings तब बनते हैं जब हम paragraph की एक लाइन देखते हैं जो [setext heading underline] है।

Reference link definitions का पता तब लगता है जब paragraph closed होता है; accumulated text lines को पार्स किया जाता है यह देखने के लिए कि क्या वे एक या अधिक reference link definitions से शुरू होती हैं। कोई भी शेष सामान्य paragraph बन जाता है।

हम देख सकते हैं कि यह कैसे काम करता है Markdown की चार लाइनों द्वारा ऊपर का tree कैसे उत्पन्न होता है इस पर विचार करके:

```markdown
> Lorem ipsum dolor
> sit amet.
>
> - Qui _quodsi iracundia_
> - aliquando id
```

शुरुआत में, हमारा document model केवल है

```tree
-> document
```

हमारे टेक्स्ट की पहली लाइन,

```markdown
> Lorem ipsum dolor
```

हमारे open `document` block के child के रूप में `block_quote` block को बनाने का कारण बनती है, और `block_quote` के child के रूप में `paragraph` block। फिर टेक्स्ट को अंतिम open block, `paragraph` में जोड़ा जाता है:

```tree
-> document
  -> block_quote
    -> paragraph
         "Lorem ipsum dolor"
```

अगली लाइन,

```markdown
sit amet.
```

open `paragraph` का "lazy continuation" है, इसलिए इसे paragraph के टेक्स्ट में जोड़ा जाता है:

```tree
-> document
  -> block_quote
    -> paragraph
         "Lorem ipsum dolor\nsit amet."
```

तीसरी लाइन,

```markdown
> - Qui _quodsi iracundia_
```

`paragraph` block को closed करने का कारण बनती है, और `block_quote` के child के रूप में एक नया `list` block खोला जाता है। `list` के child के रूप में `list_item` भी जोड़ा जाता है, और `list_item` के child के रूप में `paragraph`। फिर टेक्स्ट को नए `paragraph` में जोड़ा जाता है:

```tree
-> document
  -> block_quote
       paragraph
         "Lorem ipsum dolor\nsit amet."
    -> list (type=bullet tight=true bullet_char=-)
      -> list_item
        -> paragraph
             "Qui *quodsi iracundia*"
```

चौथी लाइन,

```markdown
> - aliquando id
```

`list_item` (और इसके child `paragraph`) को closed करने का कारण बनती है, और `list` के child के रूप में एक नया `list_item` खोला जाता है। टेक्स्ट को शामिल करने के लिए नए `list_item` के child के रूप में `paragraph` जोड़ा जाता है। इस प्रकार हम अंतिम tree प्राप्त करते हैं:

```tree
-> document
  -> block_quote
       paragraph
         "Lorem ipsum dolor\nsit amet."
    -> list (type=bullet tight=true bullet_char=-)
         list_item
           paragraph
             "Qui *quodsi iracundia*"
      -> list_item
        -> paragraph
             "aliquando id"
```

## चरण 2: इनलाइन संरचना

एक बार सभी इनपुट पार्स हो जाने के बाद, सभी open blocks closed हो जाते हैं।

फिर हम "tree को walk करते हैं," प्रत्येक node को visit करते हैं, और पैराग्राफ और हेडिंग्स की raw string सामग्री को inlines के रूप में पार्स करते हैं। इस बिंदु पर हमने सभी link reference definitions देखी हैं, इसलिए हम जाते-जाते reference links को resolve कर सकते हैं।

```tree
document
  block_quote
    paragraph
      str "Lorem ipsum dolor"
      softbreak
      str "sit amet."
    list (type=bullet tight=true bullet_char=-)
      list_item
        paragraph
          str "Qui "
          emph
            str "quodsi iracundia"
      list_item
        paragraph
          str "aliquando id"
```

ध्यान दें कि पहले paragraph में [line ending] को `softbreak` के रूप में कैसे पार्स किया गया है, और पहले list item में asterisks `emph` बन गए हैं।

### नेस्टेड ज़ोर और लिंक्स को पार्स करने के लिए एक algorithm

इनलाइन पार्सिंग का अब तक का सबसे मुश्किल हिस्सा ज़ोर, strong ज़ोर, लिंक्स, और छवियों को संभालना है। यह निम्नलिखित algorithm का उपयोग करके किया जाता है।

जब हम inlines को पार्स कर रहे होते हैं और हम या तो

- `*` या `_` वर्णों की एक run, या
- `[` या `![`

को hit करते हैं

तो हम इन प्रतीकों को इसकी शाब्दिक सामग्री के रूप में एक text node डालते हैं, और हम इस text node के लिए [delimiter stack](@) में एक pointer जोड़ते हैं।

[delimiter stack] एक doubly linked list है। प्रत्येक element में text node के लिए एक pointer होता है, साथ ही इसके बारे में जानकारी

- delimiter का प्रकार (`[`, `![`, `*`, `_`)
- delimiters की संख्या,
- क्या delimiter "active" है (सभी शुरू करने के लिए active हैं), और
- क्या delimiter संभावित opener, संभावित closer, या दोनों है (जो इस पर निर्भर करता है कि delimiters से पहले और बाद में किस प्रकार के वर्ण हैं)।

जब हम `]` वर्ण को hit करते हैं, तो हम _look for link or image_ प्रक्रिया को कॉल करते हैं (नीचे देखें)।

जब हम इनपुट के अंत को hit करते हैं, तो हम `stack_bottom` = NULL के साथ _process emphasis_ प्रक्रिया को कॉल करते हैं (नीचे देखें)।

#### _look for link or image_

delimiter stack के शीर्ष से शुरू करते हुए, हम शुरुआती `[` या `![` delimiter के लिए stack के माध्यम से पीछे की ओर देखते हैं।

- यदि हम एक नहीं पाते हैं, तो हम शाब्दिक text node `]` return करते हैं।

- यदि हम एक पाते हैं, लेकिन यह _active_ नहीं है, तो हम stack से inactive delimiter को हटाते हैं, और शाब्दिक text node `]` return करते हैं।

- यदि हम एक पाते हैं और यह active है, तो हम यह देखने के लिए आगे पार्स करते हैं कि क्या हमारे पास inline link/image, reference link/image, compact reference link/image, या shortcut reference link/image है।
  - यदि हम नहीं पाते हैं, तो हम delimiter stack से शुरुआती delimiter को हटाते हैं और शाब्दिक text node `]` return करते हैं।

  - यदि हम पाते हैं, तो
    - हम link या image node return करते हैं जिसके children शुरुआती delimiter द्वारा pointed text node के बाद inlines हैं।

    - हम इन inlines पर _process emphasis_ चलाते हैं, `[` opener को `stack_bottom` के रूप में।

    - हम शुरुआती delimiter को हटाते हैं।

    - यदि हमारे पास link है (और image नहीं), तो हम शुरुआती delimiter से पहले सभी `[` delimiters को भी _inactive_ पर सेट करते हैं। (यह हमें links के भीतर links प्राप्त करने से रोकेगा।)

#### _process emphasis_

Parameter `stack_bottom` [delimiter stack] में हम कितना नीचे उतरते हैं इसके लिए निचली सीमा सेट करता है। यदि यह NULL है, तो हम पूरे bottom तक जा सकते हैं। अन्यथा, हम `stack_bottom` को visit करने से पहले रुकते हैं।

`current_position` को [delimiter stack] पर `stack_bottom` के ठीक ऊपर element को point करने दें (या पहला element यदि `stack_bottom` NULL है)।

हम प्रत्येक delimiter type (`*`, `_`) और समापन delimiter run की प्रत्येक लंबाई (modulo 3) के लिए `openers_bottom` का track रखते हैं। इसे `stack_bottom` पर initialize करें।

फिर हम निम्नलिखित को तब तक दोहराते हैं जब तक हम संभावित closers से बाहर नहीं हो जाते:

- delimiter stack में `current_position` को आगे बढ़ाएं (यदि आवश्यक हो) जब तक हम delimiter `*` या `_` के साथ पहला संभावित closer नहीं पाते। (यह इनपुट की शुरुआत के सबसे करीब संभावित closer होगा -- parse order में पहला।)

- अब, पहले मिलते संभावित opener के लिए stack में पीछे देखें (इस delimiter type के लिए `stack_bottom` और `openers_bottom` के ऊपर रहें) ("matching" का अर्थ है समान delimiter)।

- यदि एक मिलता है:
  - पता लगाएं कि हमारे पास emphasis या strong emphasis है: यदि closer और opener spans दोनों की लंबाई >= 2 है, तो हमारे पास strong है, अन्यथा regular।

  - opener के अनुरूप text node के बाद, तदनुसार emph या strong emph node डालें।

  - delimiter stack से opener और closer के बीच किसी भी delimiters को हटा दें।

  - शुरुआती और समापन text nodes से 1 (regular emph के लिए) या 2 (strong emph के लिए) delimiters हटा दें। यदि वे परिणामस्वरूप खाली हो जाते हैं, तो उन्हें हटा दें और delimiter stack के संबंधित element को हटा दें। यदि समापन node हटाया जाता है, तो `current_position` को stack में अगले element पर reset करें।

- यदि कोई नहीं मिलता:
  - `openers_bottom` को `current_position` से पहले element पर सेट करें। (हम जानते हैं कि इस point तक और including इस प्रकार के closer के लिए कोई openers नहीं हैं, इसलिए यह भविष्य की searches पर निचली सीमा डालता है।)

  - यदि `current_position` पर closer संभावित opener नहीं है, तो इसे delimiter stack से हटा दें (क्योंकि हम जानते हैं कि यह closer भी नहीं हो सकता)।

  - stack में अगले element पर `current_position` को advance करें।

हमारे पूर्ण होने के बाद, हम delimiter stack से `stack_bottom` के ऊपर सभी delimiters को हटाते हैं।
