{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index.cjs.js","sourcesContent":["/* @jsx h */\n/**\n * markdown-to-jsx@6 is a fork of [simple-markdown v0.2.2](https://github.com/Khan/simple-markdown)\n * from Khan Academy. Thank you Khan devs for making such an awesome and extensible\n * parsing infra... without it, half of the optimizations here wouldn't be feasible. ðŸ™ðŸ¼\n */\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport unquote from 'unquote';\n\nconst getType = Object.prototype.toString;\n\n/** TODO: Drop for React 16? */\nconst ATTRIBUTE_TO_JSX_PROP_MAP = {\n    'accept-charset': 'acceptCharset',\n    'accesskey': 'accessKey',\n    'allowfullscreen': 'allowFullScreen',\n    'allowtransparency': 'allowTransparency',\n    'autocomplete': 'autoComplete',\n    'autofocus': 'autoFocus',\n    'autoplay': 'autoPlay',\n    'cellpadding': 'cellPadding',\n    'cellspacing': 'cellSpacing',\n    'charset': 'charSet',\n    'class': 'className',\n    'classid': 'classId',\n    'colspan': 'colSpan',\n    'contenteditable': 'contentEditable',\n    'contextmenu': 'contextMenu',\n    'crossorigin': 'crossOrigin',\n    'enctype': 'encType',\n    'for': 'htmlFor',\n    'formaction': 'formAction',\n    'formenctype': 'formEncType',\n    'formmethod': 'formMethod',\n    'formnovalidate': 'formNoValidate',\n    'formtarget': 'formTarget',\n    'frameborder': 'frameBorder',\n    'hreflang': 'hrefLang',\n    'http-equiv': 'httpEquiv',\n    'inputmode': 'inputMode',\n    'keyparams': 'keyParams',\n    'keytype': 'keyType',\n    'marginheight': 'marginHeight',\n    'marginwidth': 'marginWidth',\n    'maxlength': 'maxLength',\n    'mediagroup': 'mediaGroup',\n    'minlength': 'minLength',\n    'novalidate': 'noValidate',\n    'radiogroup': 'radioGroup',\n    'readonly': 'readOnly',\n    'rowspan': 'rowSpan',\n    'spellcheck': 'spellCheck',\n    'srcdoc': 'srcDoc',\n    'srclang': 'srcLang',\n    'srcset': 'srcSet',\n    'tabindex': 'tabIndex',\n    'usemap': 'useMap',\n};\n\n/** TODO: Write explainers for each of these */\nconst ATTR_EXTRACTOR_R = /([-A-Za-z0-9_]+)(?:\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|([^>\\s]+)))?/g;\nconst AUTOLINK_MAILTO_CHECK_R = /mailto:/i;\nconst BLOCK_END_R = /\\n{2,}$/;\nconst BLOCKQUOTE_R = /^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/;\nconst BLOCKQUOTE_TRIM_LEFT_MULTILINE_R = /^ *> ?/gm;\nconst BREAK_LINE_R = /^ {2,}\\n/;\nconst BREAK_THEMATIC_R = /^( *[-*_]){3,} *(?:\\n *)+\\n/;\nconst CODE_BLOCK_FENCED_R = /^\\s*(`{3,}|~{3,}) *(\\S+)? *\\n([\\s\\S]+?)\\s*\\1 *(?:\\n *)+\\n/;\nconst CODE_BLOCK_R = /^(?: {4}[^\\n]+\\n*)+(?:\\n *)+\\n/;\nconst CODE_INLINE_R = /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/;\nconst CONSECUTIVE_NEWLINE_R = /^(?:\\n *)*\\n/;\nconst CR_NEWLINE_R = /\\r\\n?/g;\nconst FOOTNOTE_R = /^\\[\\^(.*)\\](:.*)\\n/;\nconst FOOTNOTE_REFERENCE_R = /^\\[\\^(.*)\\]/;\nconst FORMFEED_R = /\\f/g;\nconst GFM_TASK_R = /^\\s*?\\[(x|\\s)\\]/;\nconst HEADING_R = /^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n *)+\\n/;\nconst HEADING_SETEXT_R = /^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/;\nconst HTML_BLOCK_ELEMENT_R = /^<(.*)\\s?(.*?)>(.*?)<\\/\\1>/;\nconst HTML_COMMENT_R = /^<!--.*?-->/;\nconst HTML_SELF_CLOSING_ELEMENT_R = /^<([^\\s]*)\\s?(.*?)>(.*?)(?!<\\/\\1>)/;\nconst LINK_AUTOLINK_BARE_URL_R = /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/;\nconst LINK_AUTOLINK_MAILTO_R = /^<([^ >]+@[^ >]+)>/;\nconst LINK_AUTOLINK_R = /^<([^ >]+:\\/[^ >]+)>/;\nconst LIST_ITEM_END_R = / *\\n+$/;\nconst LIST_LOOKBEHIND_R = /^$|\\n *$/;\nconst NP_TABLE_R = /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/;\nconst NPTABLE_CELLS_TRIM = /\\n$/;\nconst PARAGRAPH_R = /^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/;\nconst REFERENCE_IMAGE_OR_LINK = /^\\[([^\\]]*)\\]:\\s*(\\S+)\\s*(\"([^\"]*)\")?/;\nconst REFERENCE_IMAGE_R = /^!\\[([^\\]]*)\\]\\[([^\\]]*)\\]/;\nconst REFERENCE_LINK_R = /^\\[([^\\]]*)\\]\\[([^\\]]*)\\]/;\nconst TAB_R = /\\t/g;\nconst TABLE_ALIGN_TRIM = /^ *|\\| *$/g;\nconst TABLE_CENTER_ALIGN = /^ *:-+: *$/;\nconst TABLE_HEADER_TRIM = /^ *| *\\| *$/g;\nconst TABLE_LEFT_ALIGN = /^ *:-+ *$/;\nconst TABLE_RIGHT_ALIGN = /^ *-+: *$/;\nconst TABLE_ROW_SPLIT = / *\\| */;\nconst TEXT_BOLD_R = /^[*_]{2}([\\s\\S]+?)[*_]{2}(?!\\*|_)/;\nconst TEXT_EMPHASIZED_R = /^[*_]{1}([\\s\\S]+?)[*_]{1}(?!\\*|_)/;\nconst TEXT_ESCAPED_R = /^\\\\([^0-9A-Za-z\\s])/;\nconst TEXT_PLAIN_R = /^[\\s\\S]+?(?=[^0-9A-Za-z\\s\\u00c0-\\uffff]|\\n\\n| {2,}\\n|\\w+:\\S|$)/;\nconst TEXT_STRIKETHROUGHED_R = /^~~(?=\\S)([\\s\\S]*?\\S)~~/;\nconst UNESCAPE_URL_R = /\\\\([^0-9A-Za-z\\s])/g;\n\n// recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\nconst LIST_BULLET = '(?:[*+-]|\\\\d+\\\\.)';\n\n// recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\nconst LIST_ITEM_PREFIX = '( *)(' + LIST_BULLET + ') +';\nconst LIST_ITEM_PREFIX_R = new RegExp('^' + LIST_ITEM_PREFIX);\n\n// recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\nconst LIST_ITEM_R = new RegExp(\n    LIST_ITEM_PREFIX +\n    '[^\\\\n]*(?:\\\\n' +\n    '(?!\\\\1' + LIST_BULLET + ' )[^\\\\n]*)*(\\n|$)',\n    'gm'\n);\n\n// check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\nconst LIST_R = new RegExp(\n    '^( *)(' + LIST_BULLET + ') ' +\n    '[\\\\s\\\\S]+?(?:\\n{2,}(?! )' +\n    '(?!\\\\1' + LIST_BULLET + ' )\\\\n*' +\n    // the \\\\s*$ here is so that we can parse the inside of nested\n    // lists, where our content might end before we receive two `\\n`s\n    '|\\\\s*\\n*$)'\n);\n\nconst LINK_INSIDE = '(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*';\nconst LINK_HREF_AND_TITLE = '\\\\s*<?((?:[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+[\\'\"]([\\\\s\\\\S]*?)[\\'\"])?\\\\s*';\n\nconst LINK_R = new RegExp(\n    '^\\\\[(' + LINK_INSIDE + ')\\\\]\\\\(' + LINK_HREF_AND_TITLE + '\\\\)'\n);\n\nconst IMAGE_R = new RegExp(\n    '^!\\\\[(' + LINK_INSIDE + ')\\\\]\\\\(' + LINK_HREF_AND_TITLE + '\\\\)'\n);\n\nfunction parseTableAlignCapture (alignCapture) {\n    if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n        return 'right';\n    } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n        return 'center';\n    } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n        return 'left';\n    } else {\n        return null;\n    }\n}\n\nfunction parseTableHeader (capture, parse, state) {\n    let headerText = capture[1]\n        .replace(TABLE_HEADER_TRIM, '')\n        .split(TABLE_ROW_SPLIT);\n    return headerText.map(function (text) {\n        return parse(text, state);\n    });\n}\n\nfunction parseTableAlign (capture/*, parse, state*/) {\n    let alignText = capture[2]\n        .replace(TABLE_ALIGN_TRIM, '')\n        .split(TABLE_ROW_SPLIT);\n\n    return alignText.map(parseTableAlignCapture);\n}\n\nfunction parseTableCells (capture, parse, state) {\n    let rowsText = capture[3]\n        .replace(NPTABLE_CELLS_TRIM, '')\n        .split('\\n');\n\n    return rowsText.map(function (rowText) {\n        let cellText = rowText.split(TABLE_ROW_SPLIT);\n        return cellText.map(function (text) {\n            return parse(text, state);\n        });\n    });\n}\n\nfunction parseTable (capture, parse, state) {\n    state.inline = true;\n    let header = parseTableHeader(capture, parse, state);\n    let align = parseTableAlign(capture, parse, state);\n    let cells = parseTableCells(capture, parse, state);\n    state.inline = false;\n\n    return {\n        align: align,\n        cells: cells,\n        header: header,\n        type: 'table',\n    };\n}\n\nfunction attributeValueToJSXPropValue (key, value) {\n    if (key === 'style') {\n        return value.split(/;\\s?/).reduce(function (styles, kvPair) {\n\n            const key = kvPair.slice(0, kvPair.indexOf(':'));\n\n            // snake-case to camelCase\n            // also handles PascalCasing vendor prefixes\n            const camelCasedKey = key.replace(/(-[a-z])/g, function toUpper (substr) {\n                return substr[1].toUpperCase();\n            });\n\n            // key.length + 1 to skip over the colon\n            styles[camelCasedKey] = kvPair.slice(key.length + 1).trim();\n\n            return styles;\n\n        }, {});\n    }\n\n    return value;\n}\n\nfunction attrStringToMap (str) {\n    const attributes = str.match(ATTR_EXTRACTOR_R);\n\n    return attributes ? attributes.reduce(function (map, raw) {\n        const tuple = raw.split('=');\n        const key = tuple[0];\n        const value = tuple[1];\n\n        map[ATTRIBUTE_TO_JSX_PROP_MAP[key] || key] = attributeValueToJSXPropValue(key, unquote(value));\n\n        return map;\n    }, {}) : undefined;\n}\n\n// Turn various crazy whitespace into easy to process things\nfunction preprocess (source) {\n    return source.replace(CR_NEWLINE_R, '\\n')\n        .replace(FORMFEED_R, '')\n        .replace(TAB_R, '    ');\n}\n\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @rules: an object containing\n * rule type -> {match, order, parse} objects\n * (lower order is higher precedence)\n * (Note: `order` is added to defaultRules after creation so that\n *  the `order` of defaultRules in the source matches the `order`\n *  of defaultRules in terms of `order` fields.)\n *\n * @returns The resulting parse function, with the following parameters:\n *   @source: the input source string to be parsed\n *   @state: an optional object to be threaded through parse\n *     calls. Allows clients to add stateful operations to\n *     parsing, such as keeping track of how many levels deep\n *     some nesting is. For an example use-case, see passage-ref\n *     parsing in src/widgets/passage/passage-markdown.jsx\n */\nfunction parserFor (rules) {\n    // Sorts rules in order of increasing order, then\n    // ascending rule name in case of ties.\n    let ruleList = Object.keys(rules);\n\n    /* istanbul ignore next */\n    if (process.env.NODE_ENV !== 'production') {\n        ruleList.forEach(function (type) {\n            let order = rules[type].order;\n            if (\n                process.env.NODE_ENV !== 'production'\n                && (typeof order !== 'number' || !isFinite(order))\n                && typeof console !== 'undefined'\n            ) {\n                console.warn(\n                    'simple-markdown: Invalid order for rule `' + type + '`: ' +\n                    order\n                );\n            }\n        });\n    }\n\n    ruleList.sort(function (typeA, typeB) {\n        let orderA = rules[typeA].order;\n        let orderB = rules[typeB].order;\n\n        // First sort based on increasing order\n        if (orderA !== orderB) {\n            return orderA - orderB;\n\n        // Then based on increasing unicode lexicographic ordering\n        } else if (typeA < typeB) {\n            return -1;\n        }\n\n        return 1;\n    });\n\n    function nestedParse (source, state) {\n        let result = [];\n\n        // We store the previous capture so that match functions can\n        // use some limited amount of lookbehind. Lists use this to\n        // ensure they don't match arbitrary '- ' or '* ' in inline\n        // text (see the list rule for more information).\n        let prevCapture = '';\n        while (source) {\n            let i = 0;\n            while (i < ruleList.length) {\n                let ruleType = ruleList[i];\n                let rule = rules[ruleType];\n                let capture = rule.match(source, state, prevCapture);\n\n                if (capture) {\n                    let currCaptureString = capture[0];\n                    source = source.substring(currCaptureString.length);\n                    let parsed = rule.parse(capture, nestedParse, state);\n\n                    // We also let rules override the default type of\n                    // their parsed node if they would like to, so that\n                    // there can be a single output function for all links,\n                    // even if there are several rules to parse them.\n                    if (parsed.type == null) {\n                        parsed.type = ruleType;\n                    }\n\n                    result.push(parsed);\n\n                    prevCapture = currCaptureString;\n                    break;\n                }\n\n                i++;\n            }\n        }\n\n        return result;\n    }\n\n    return function outerParse (source, state) {\n        return nestedParse(preprocess(source), state);\n    };\n}\n\n// Creates a match function for an inline scoped element from a regex\nfunction inlineRegex (regex) {\n    function match (source, state) {\n        if (state.inline) {\n            return regex.exec(source);\n        } else {\n            return null;\n        }\n    }\n\n    match.regex = regex;\n\n    return match;\n}\n\n// Creates a match function for a block scoped element from a regex\nfunction blockRegex (regex) {\n    function match (source, state) {\n        if (state.inline) {\n            return null;\n        } else {\n            return regex.exec(source);\n        }\n    }\n\n    match.regex = regex;\n\n    return match;\n}\n\n// Creates a match function from a regex, ignoring block/inline scope\nfunction anyScopeRegex (regex) {\n    function match (source/*, state*/) {\n        return regex.exec(source);\n    }\n\n    match.regex = regex;\n\n    return match;\n}\n\nfunction reactFor (outputFunc) {\n    return function nestedReactOutput (ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            let oldKey = state.key;\n            let result = [];\n\n            // map nestedOutput over the ast, except group any text\n            // nodes together into a single string output.\n            let lastWasString = false;\n            for (let i = 0; i < ast.length; i++) {\n                state.key = i;\n                let nodeOut = nestedReactOutput(ast[i], state);\n                let isString = (typeof nodeOut === 'string');\n                if (isString && lastWasString) {\n                    result[result.length - 1] += nodeOut;\n                } else {\n                    result.push(nodeOut);\n                }\n                lastWasString = isString;\n            }\n\n            state.key = oldKey;\n            return result;\n        } else {\n            return outputFunc(ast, nestedReactOutput, state);\n        }\n    };\n}\n\nfunction sanitizeUrl (url) {\n    try {\n        let prot = decodeURIComponent(url)\n            .replace(/[^A-Za-z0-9/:]/g, '')\n            .toLowerCase();\n        if (prot.indexOf('javascript:') === 0) {\n            return null;\n        }\n    } catch (e) {\n        // decodeURIComponent sometimes throws a URIError\n        // See `decodeURIComponent('a%AFc');`\n        // http://stackoverflow.com/questions/9064536/javascript-decodeuricomponent-malformed-uri-exception\n        return null;\n    }\n\n    return url;\n}\n\nfunction unescapeUrl (rawUrlString) {\n    return rawUrlString.replace(UNESCAPE_URL_R, '$1');\n}\n\n// Parse some content with the parser `parse`, with state.inline\n// set to true. Useful for block elements; not generally necessary\n// to be used by inline elements (where state.inline is already true.\nfunction parseInline (parse, content, state) {\n    let isCurrentlyInline = state.inline || false;\n    state.inline = true;\n    let result = parse(content, state);\n    state.inline = isCurrentlyInline;\n    return result;\n}\n\nfunction parseBlock (parse, content, state) {\n    state.inline = false;\n    return parse(content + '\\n\\n', state);\n}\n\nfunction parseCaptureInline (capture, parse, state) {\n    return {\n        content: parseInline(parse, capture[1], state),\n    };\n}\n\nfunction captureNothing () { return {}; }\nfunction renderNothing () { return null; }\n\nfunction ruleOutput (rules) {\n    return function nestedRuleOutput (ast, outputFunc, state) {\n        return rules[ast.type].react(ast, outputFunc, state);\n    };\n}\n\nfunction cx (...str) {\n    return str.filter(Boolean).join(' ');\n}\n\nfunction get (src, path, fb) {\n    let ptr = src;\n    const frags = path.split('.');\n\n    while (frags.length) {\n        ptr = ptr[frags[0]];\n\n        if (ptr === undefined) break;\n        else frags.shift();\n    }\n\n    return ptr || fb;\n}\n\n/**\n * anything that must scan the tree before everything else\n */\nconst PARSE_PRIORITY_MAX = 1;\n\n/**\n * scans for block-level constructs\n */\nconst PARSE_PRIORITY_HIGH = 2;\n\n/**\n * inline w/ more priority than other inline\n */\nconst PARSE_PRIORITY_MED = 3;\n\n/**\n * inline elements\n */\nconst PARSE_PRIORITY_LOW = 4;\n\n/**\n * bare text and stuff that is considered leftovers\n */\nconst PARSE_PRIORITY_MIN = 5;\n\nexport function compiler (markdown, options) {\n    options = options || {};\n    options.overrides = options.overrides || {};\n\n    // eslint-disable-next-line no-unused-vars\n    function h (tag, props, ...children) {\n        const overrideProps = get(options.overrides, `${tag}.props`, {});\n        return React.createElement(\n            get(options.overrides, `${tag}.component`, tag), {\n                ...overrideProps,\n                ...props,\n                className: cx(props && props.className, overrideProps.className) || undefined,\n            }, ...children\n        );\n    }\n\n    /* istanbul ignore next */\n    if (process.env.NODE_ENV !== 'production') {\n        if (typeof markdown !== 'string') {\n            throw new Error(`markdown-to-jsx: the first argument must be\n                             a string`);\n        }\n\n        if (getType.call(options.overrides) !== '[object Object]') {\n            throw new Error(`markdown-to-jsx: options.overrides (second argument property) must be\n                             undefined or an object literal with shape:\n                             {\n                                htmltagname: {\n                                    component: string|ReactComponent(optional),\n                                    props: object(optional)\n                                }\n                             }`);\n        }\n    }\n\n    const footnotes = [];\n    const refs = {};\n\n    /**\n     * each rule's react() output function goes through our custom h() JSX pragma;\n     * this allows the override functionality to be automatically applied\n     */\n    const rules = {\n        blockQuote: {\n            match: blockRegex(BLOCKQUOTE_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse (capture, parse, state) {\n                return {\n                    content: parse(capture[0].replace(BLOCKQUOTE_TRIM_LEFT_MULTILINE_R, ''), state),\n                };\n            },\n            react (node, output, state) {\n                return (\n                    <blockquote key={state.key}>\n                        {output(node.content, state)}\n                    </blockquote>\n                );\n            },\n        },\n\n        breakLine: {\n            match: anyScopeRegex(BREAK_LINE_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse: captureNothing,\n            react (_, __, state) {\n                return (\n                    <br key={state.key} />\n                );\n            },\n        },\n\n        breakThematic: {\n            match: blockRegex(BREAK_THEMATIC_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse: captureNothing,\n            react (_, __, state) {\n                return (\n                    <hr key={state.key} />\n                );\n            },\n        },\n\n        codeBlock: {\n            match: blockRegex(CODE_BLOCK_R),\n            order: PARSE_PRIORITY_MAX,\n            parse (capture/*, parse, state*/) {\n                let content = capture[0]\n                    .replace(/^ {4}/gm, '')\n                    .replace(/\\n+$/, '');\n                return {\n                    content: content,\n                    lang: undefined,\n                };\n            },\n\n            react (node, output, state) {\n                return (\n                    <pre key={state.key}>\n                        <code className={node.lang ? `lang-${node.lang}` : ''}>\n                            {node.content}\n                        </code>\n                    </pre>\n                );\n            },\n        },\n\n        codeFenced: {\n            match: blockRegex(CODE_BLOCK_FENCED_R),\n            order: PARSE_PRIORITY_MAX,\n            parse (capture/*, parse, state*/) {\n                return {\n                    content: capture[3],\n                    lang: capture[2] || undefined,\n                    type: 'codeBlock',\n                };\n            },\n        },\n\n        codeInline: {\n            match: inlineRegex(CODE_INLINE_R),\n            order: PARSE_PRIORITY_LOW,\n            parse (capture/*, parse, state*/) {\n                return {\n                    content: capture[2],\n                };\n            },\n            react (node, output, state) {\n                return (\n                    <code key={state.key}>\n                        {node.content}\n                    </code>\n                );\n            },\n        },\n\n        /**\n         * footnotes are emitted at the end of compilation in a special <footer> block\n         */\n        footnote: {\n            match: blockRegex(FOOTNOTE_R),\n            order: PARSE_PRIORITY_MAX,\n            parse (capture/*, parse, state*/) {\n                footnotes.push({\n                    footnote: capture[2],\n                    identifier: capture[1],\n                });\n\n                return {};\n            },\n            react: renderNothing,\n        },\n\n        footnoteReference: {\n            match: inlineRegex(FOOTNOTE_REFERENCE_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse (capture/*, parse*/) {\n                return {\n                    content: capture[1],\n                    target: `#${capture[1]}`,\n                };\n            },\n            react (node, output, state) {\n                return (\n                    <a key={state.key} href={sanitizeUrl(node.target)}>\n                        <sup key={state.key}>\n                            {node.content}\n                        </sup>\n                    </a>\n                );\n            },\n        },\n\n        gfmTask: {\n            match: inlineRegex(GFM_TASK_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse (capture/*, parse, state*/) {\n                return {\n                    completed: capture[1].toLowerCase() === 'x',\n                };\n            },\n            react (node, output, state) {\n                return (\n                    <input\n                        checked={node.completed}\n                        key={state.key}\n                        readOnly\n                        type=\"checkbox\"\n                    />\n                );\n            },\n        },\n\n        heading: {\n            match: blockRegex(HEADING_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse (capture, parse, state) {\n                return {\n                    content: parseInline(parse, capture[2], state),\n                    level: capture[1].length,\n                };\n            },\n            react (node, output, state) {\n                const Tag = `h${node.level}`;\n                return (\n                    <Tag key={state.key}>\n                        {output(node.content, state)}\n                    </Tag>\n                );\n            },\n        },\n\n        headingSetext: {\n            match: blockRegex(HEADING_SETEXT_R),\n            order: PARSE_PRIORITY_MAX,\n            parse (capture, parse, state) {\n                return {\n                    content: parseInline(parse, capture[1], state),\n                    level: capture[2] === '=' ? 1 : 2,\n                    type: 'heading',\n                };\n            },\n        },\n\n        htmlBlock: {\n            /**\n             * find the first matching end tag and process the interior\n             */\n            match: anyScopeRegex(HTML_BLOCK_ELEMENT_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse (capture, parse, state) {\n                const parseFunc = capture[3].match(HTML_BLOCK_ELEMENT_R) ? parseBlock : parseInline;\n\n                return {\n                    attrs: attrStringToMap(capture[2]),\n                    /**\n                     * if another html block is detected within, parse as block,\n                     * otherwise parse as inline to pick up any further markdown\n                     */\n                    content: parseFunc(parse, capture[3], state),\n\n                    tag: capture[1],\n                };\n            },\n            react (node, output, state) {\n                return (\n                    <node.tag key={state.key} {...node.attrs}>\n                        {output(node.content, state)}\n                    </node.tag>\n                );\n            },\n        },\n\n        htmlComment: {\n            match: anyScopeRegex(HTML_COMMENT_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse () { return {}; },\n            react: renderNothing,\n        },\n\n        htmlSelfClosing: {\n\n            /**\n             * find the first matching end tag and process the interior\n             */\n            match: inlineRegex(HTML_SELF_CLOSING_ELEMENT_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse (capture/*, parse, state*/) {\n                return {\n                    attrs: attrStringToMap(capture[2]),\n                    tag: capture[1],\n                };\n            },\n            react (node, output, state) {\n                return (\n                    <node.tag\n                        {...node.attrs}\n                        key={state.key}\n                    />\n                );\n            },\n        },\n\n        image: {\n            match: inlineRegex(IMAGE_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse (capture/*, parse, state*/) {\n                let image = {\n                    alt: capture[1],\n                    target: unescapeUrl(capture[2]),\n                    title: capture[3],\n                };\n                return image;\n            },\n            react (node, output, state) {\n                return (\n                    <img\n                        key={state.key}\n                        alt={node.alt || undefined}\n                        title={node.title || undefined}\n                        src={sanitizeUrl(node.target)}\n                    />\n                );\n            },\n        },\n\n        link: {\n            match: inlineRegex(LINK_R),\n            order: PARSE_PRIORITY_LOW,\n            parse (capture, parse, state) {\n                let link ={\n                    content: parse(capture[1], state),\n                    target: unescapeUrl(capture[2]),\n                    title: capture[3],\n                };\n                return link;\n            },\n            react (node, output, state) {\n                return (\n                    <a\n                        key={state.key}\n                        href={sanitizeUrl(node.target)}\n                        title={node.title}\n                    >\n                        {output(node.content, state)}\n                    </a>\n                );\n            },\n        },\n\n        // https://daringfireball.net/projects/markdown/syntax#autolink\n        linkAngleBraceStyleDetector: {\n            match: inlineRegex(LINK_AUTOLINK_R),\n            order: PARSE_PRIORITY_MAX,\n            parse (capture/*, parse, state*/) {\n                return {\n                    content: [{\n                        content: capture[1],\n                        type: 'text',\n                    }],\n                    target: capture[1],\n                    type: 'link',\n                };\n            },\n        },\n\n        linkBareUrlDetector: {\n            match: inlineRegex(LINK_AUTOLINK_BARE_URL_R),\n            order: PARSE_PRIORITY_MAX,\n            parse (capture/*, parse, state*/) {\n                return {\n                    content: [{\n                        content: capture[1],\n                        type: 'text',\n                    }],\n                    target: capture[1],\n                    title: undefined,\n                    type: 'link',\n                };\n            },\n        },\n\n        linkMailtoDetector: {\n            match: inlineRegex(LINK_AUTOLINK_MAILTO_R),\n            order: PARSE_PRIORITY_MAX,\n            parse (capture/*, parse, state*/) {\n                let address = capture[1];\n                let target = capture[1];\n\n                // Check for a `mailto:` already existing in the link:\n                if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n                    target = 'mailto:' + target;\n                }\n\n                return {\n                    content: [{\n                        content: address.replace('mailto:', ''),\n                        type: 'text',\n                    }],\n                    target: target,\n                    type: 'link',\n                };\n            },\n        },\n\n        list: {\n            match (source, state, prevCapture) {\n                // We only want to break into a list if we are at the start of a\n                // line. This is to avoid parsing \"hi * there\" with \"* there\"\n                // becoming a part of a list.\n                // You might wonder, \"but that's inline, so of course it wouldn't\n                // start a list?\". You would be correct! Except that some of our\n                // lists can be inline, because they might be inside another list,\n                // in which case we can parse with inline scope, but need to allow\n                // nested lists inside this inline scope.\n                let isStartOfLine = LIST_LOOKBEHIND_R.test(prevCapture);\n                let isListBlock = state._list || !state.inline;\n\n                if (isStartOfLine && isListBlock) {\n                    return LIST_R.exec(source);\n                } else {\n                    return null;\n                }\n            },\n            order: PARSE_PRIORITY_HIGH,\n            parse (capture, parse, state) {\n                let bullet = capture[2];\n                let ordered = bullet.length > 1;\n                let start = ordered ? +bullet : undefined;\n                let items = capture[0]\n                    // recognize the end of a paragraph block inside a list item:\n                    // two or more newlines at end end of the item\n                    .replace(BLOCK_END_R, '\\n')\n                    .match(LIST_ITEM_R);\n\n                let lastItemWasAParagraph = false;\n                let itemContent = items.map(function (item, i) {\n                    // We need to see how far indented this item is:\n                    let space = LIST_ITEM_PREFIX_R.exec(item)[0].length;\n                    // And then we construct a regex to \"unindent\" the subsequent\n                    // lines of the items by that amount:\n                    let spaceRegex = new RegExp('^ {1,' + space + '}', 'gm');\n\n                    // Before processing the item, we need a couple things\n                    let content = item\n                        // remove indents on trailing lines:\n                        .replace(spaceRegex, '')\n                        // remove the bullet:\n                        .replace(LIST_ITEM_PREFIX_R, '');\n\n                    // Handling \"loose\" lists, like:\n                    //\n                    //  * this is wrapped in a paragraph\n                    //\n                    //  * as is this\n                    //\n                    //  * as is this\n                    let isLastItem = (i === items.length - 1);\n                    let containsBlocks = content.indexOf('\\n\\n') !== -1;\n\n                    // Any element in a list is a block if it contains multiple\n                    // newlines. The last element in the list can also be a block\n                    // if the previous item in the list was a block (this is\n                    // because non-last items in the list can end with \\n\\n, but\n                    // the last item can't, so we just \"inherit\" this property\n                    // from our previous element).\n                    let thisItemIsAParagraph = containsBlocks ||\n                            (isLastItem && lastItemWasAParagraph);\n                    lastItemWasAParagraph = thisItemIsAParagraph;\n\n                    // backup our state for restoration afterwards. We're going to\n                    // want to set state._list to true, and state.inline depending\n                    // on our list's looseness.\n                    let oldStateInline = state.inline;\n                    let oldStateList = state._list;\n                    state._list = true;\n\n                    // Parse inline if we're in a tight list, or block if we're in\n                    // a loose list.\n                    let adjustedContent;\n                    if (thisItemIsAParagraph) {\n                        state.inline = false;\n                        adjustedContent = content.replace(LIST_ITEM_END_R, '\\n\\n');\n                    } else {\n                        state.inline = true;\n                        adjustedContent = content.replace(LIST_ITEM_END_R, '');\n                    }\n\n                    let result = parse(adjustedContent, state);\n\n                    // Restore our state before returning\n                    state.inline = oldStateInline;\n                    state._list = oldStateList;\n                    return result;\n                });\n\n                return {\n                    items: itemContent,\n                    ordered: ordered,\n                    start: start,\n                };\n            },\n            react (node, output, state) {\n                const Tag = node.ordered ? 'ol' : 'ul';\n\n                return (\n                    <Tag key={state.key} start={node.start}>\n                        {node.items.map(function generateListItem (item, i) {\n                            return (\n                                <li key={i}>\n                                    {output(item, state)}\n                                </li>\n                            );\n                        })}\n                    </Tag>\n                );\n            },\n        },\n\n        newlineCoalescer: {\n            match: blockRegex(CONSECUTIVE_NEWLINE_R),\n            order: PARSE_PRIORITY_LOW,\n            parse: captureNothing,\n            react (/*node, output, state*/) { return '\\n'; },\n        },\n\n        paragraph: {\n            match: blockRegex(PARAGRAPH_R),\n            order: PARSE_PRIORITY_LOW,\n            parse: parseCaptureInline,\n            react (node, output, state) {\n                return (\n                    <p key={state.key}>\n                        {output(node.content, state)}\n                    </p>\n                );\n            },\n        },\n\n        ref: {\n            match: inlineRegex(REFERENCE_IMAGE_OR_LINK),\n            order: PARSE_PRIORITY_MAX,\n            parse (capture/*, parse*/) {\n                refs[capture[1]] = {\n                    target: capture[2],\n                    title: capture[4],\n                };\n\n                return {};\n            },\n            react: renderNothing,\n        },\n\n        refImage: {\n            match: inlineRegex(REFERENCE_IMAGE_R),\n            order: PARSE_PRIORITY_MAX,\n            parse (capture) {\n                return {\n                    alt: capture[1] || undefined,\n                    ref: capture[2],\n                };\n            },\n            react (node, output, state) {\n                return (\n                    <img\n                        key={state.key}\n                        alt={node.alt}\n                        src={sanitizeUrl(refs[node.ref].target)}\n                        title={refs[node.ref].title}\n                    />\n                );\n            },\n        },\n\n        refLink: {\n            match: inlineRegex(REFERENCE_LINK_R),\n            order: PARSE_PRIORITY_MAX,\n            parse (capture, parse, state) {\n                return {\n                    content: parse(capture[1], state),\n                    ref: capture[2],\n                };\n            },\n            react (node, output, state) {\n                return (\n                    <a\n                        key={state.key}\n                        href={sanitizeUrl(refs[node.ref].target)}\n                        title={refs[node.ref].title}\n                    >\n                        {output(node.content, state)}\n                    </a>\n                );\n            },\n        },\n\n        table: {\n            match: blockRegex(NP_TABLE_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse: parseTable,\n            react (node, output, state) {\n                function getStyle (colIndex) {\n                    return node.align[colIndex] == null ? {} : {\n                        textAlign: node.align[colIndex],\n                    };\n                }\n\n                return (\n                    <table key={state.key}>\n                        <thead>\n                            <tr>\n                                {node.header.map(function generateHeaderCell (content, i) {\n                                    return (\n                                        <th\n                                            key={i}\n                                            style={getStyle(i)}\n                                            scope=\"col\"\n                                        >\n                                            {output(content, state)}\n                                        </th>\n                                    );\n                                })}\n                            </tr>\n                        </thead>\n\n                        <tbody>\n                            {node.cells.map(function generateTableRow (row, i) {\n                                return (\n                                    <tr key={i}>\n                                        {row.map(function generateTableCell (content, c) {\n                                            return (\n                                                <td key={c} style={getStyle(c)}>\n                                                    {output(content, state)}\n                                                </td>\n                                            );\n                                        })}\n                                    </tr>\n                                );\n                            })}\n                        </tbody>\n                    </table>\n                );\n            },\n        },\n\n        text: {\n            // Here we look for anything followed by non-symbols,\n            // double newlines, or double-space-newlines\n            // We break on any symbol characters so that this grammar\n            // is easy to extend without needing to modify this regex\n            match: inlineRegex(TEXT_PLAIN_R),\n            order: PARSE_PRIORITY_MIN,\n            parse (capture/*, parse, state*/) {\n                return {\n                    content: capture[0],\n                };\n            },\n            react (node/*, output, state*/) {\n                return node.content;\n            },\n        },\n\n        textBolded: {\n            match: inlineRegex(TEXT_BOLD_R),\n            order: PARSE_PRIORITY_MED,\n            parse: parseCaptureInline,\n            react (node, output, state) {\n                return (\n                    <strong key={state.key}>\n                        {output(node.content, state)}\n                    </strong>\n                );\n            },\n        },\n\n        textEmphasized: {\n            match: inlineRegex(TEXT_EMPHASIZED_R),\n            order: PARSE_PRIORITY_LOW,\n            parse (capture, parse, state) {\n                return {\n                    content: parse(capture[2] || capture[1], state),\n                };\n            },\n            react (node, output, state) {\n                return (\n                    <em key={state.key}>\n                        {output(node.content, state)}\n                    </em>\n                );\n            },\n        },\n\n        textEscaped: {\n            // We don't allow escaping numbers, letters, or spaces here so that\n            // backslashes used in plain text still get rendered. But allowing\n            // escaping anything else provides a very flexible escape mechanism,\n            // regardless of how this grammar is extended.\n            match: inlineRegex(TEXT_ESCAPED_R),\n            order: PARSE_PRIORITY_HIGH,\n            parse (capture/*, parse, state*/) {\n                return {\n                    content: capture[1],\n                    type: 'text',\n                };\n            },\n        },\n\n        textStrikethroughed: {\n            match: inlineRegex(TEXT_STRIKETHROUGHED_R),\n            order: PARSE_PRIORITY_LOW,\n            parse: parseCaptureInline,\n            react (node, output, state) {\n                return (\n                    <del key={state.key}>\n                        {output(node.content, state)}\n                    </del>\n                );\n            },\n        },\n    };\n\n    const parser = parserFor(rules);\n    const emitter = reactFor(ruleOutput(rules));\n\n    /**\n     * should not contain any block-level markdown like newlines, lists, headings,\n     * thematic breaks, blockquotes, etc\n     */\n    const inline = /(\\n|^[-*]\\s|^#|^ {2,}|^-{2,}|^>\\s)/g.test(markdown) === false;\n\n    const arr = emitter(parser(inline ? markdown : `${markdown}\\n\\n`, { inline }));\n\n    let jsx;\n    if (arr.length > 1) {\n        jsx = inline ? <p>{arr}</p> : <div>{arr}</div>;\n    } else if (arr.length === 1) {\n        jsx = arr[0];\n\n        // TODO: remove this for React 16\n        if (typeof jsx === 'string') {\n            jsx = <span>{jsx}</span>;\n        }\n    }\n\n    if (footnotes.length) {\n        jsx.props.children.push(\n            <footer>\n                {footnotes.map(function createFootnote (def) {\n                    return (\n                        <div id={def.identifier} key={def.identifier}>\n                            {def.identifier}{emitter(parser(def.footnote, { inline: true }))}\n                        </div>\n                    );\n                })}\n            </footer>\n        );\n    }\n\n    return jsx;\n}\n\n/**\n * A simple HOC for easy React use. Feed the markdown content as a direct child\n * and the rest is taken care of automatically.\n *\n * @param  {String}   options.children   must be a string\n * @param  {Object}   options.options    markdown-to-jsx options (arg 2 of the compiler)\n *\n * @return {ReactElement} the compiled JSX\n */\n\nexport default function Markdown (props) {\n    return compiler(props.children, props.options);\n}\n\nMarkdown.propTypes = {\n    children: PropTypes.string.isRequired,\n    options: PropTypes.object,\n};\n"]}